{"version":3,"file":"blocknote.umd.cjs","sources":["../src/extensions/Blocks/api/block.ts","../src/extensions/Blocks/nodes/BlockContent/HeadingBlockContent/HeadingBlockContent.ts","../src/extensions/Blocks/helpers/getBlockInfoFromPos.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/ListItemKeyboardShortcuts.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/BulletListItemBlockContent/BulletListItemBlockContent.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/NumberedListItemBlockContent/NumberedListIndexingPlugin.ts","../src/extensions/Blocks/nodes/BlockContent/ListItemBlockContent/NumberedListItemBlockContent/NumberedListItemBlockContent.ts","../src/extensions/Blocks/nodes/BlockContent/ParagraphBlockContent/ParagraphBlockContent.ts","../src/extensions/Blocks/api/defaultBlocks.ts","../src/extensions/UniqueID/UniqueID.ts","../src/shared/utils.ts","../src/api/nodeConversions/nodeConversions.ts","../src/api/util/nodeUtil.ts","../src/api/blockManipulation/blockManipulation.ts","../src/api/formatConversions/removeUnderlinesRehypePlugin.ts","../src/api/formatConversions/simplifyBlocksRehypePlugin.ts","../src/api/formatConversions/formatConversions.ts","../src/extensions/BackgroundColor/BackgroundColorExtension.ts","../src/extensions/BackgroundColor/BackgroundColorMark.ts","../src/extensions/Blocks/PreviousBlockTypePlugin.ts","../src/extensions/Blocks/nodes/BlockAttributes.ts","../src/extensions/Blocks/nodes/BlockContainer.ts","../src/extensions/Blocks/nodes/BlockGroup.ts","../src/extensions/Blocks/index.ts","../src/extensions/Blocks/api/serialization.ts","../src/extensions/Blocks/helpers/findBlock.ts","../src/shared/plugins/suggestion/SuggestionPlugin.ts","../src/extensions/SlashMenu/SlashMenuExtension.ts","../src/extensions/DraggableBlocks/MultipleNodeSelection.ts","../src/extensions/DraggableBlocks/DraggableBlocksPlugin.ts","../src/extensions/DraggableBlocks/DraggableBlocksExtension.ts","../src/extensions/FormattingToolbar/FormattingToolbarPlugin.ts","../src/extensions/FormattingToolbar/FormattingToolbarExtension.ts","../src/extensions/HyperlinkToolbar/HyperlinkToolbarPlugin.ts","../src/extensions/HyperlinkToolbar/HyperlinkMark.ts","../src/extensions/Placeholder/PlaceholderExtension.ts","../src/shared/plugins/suggestion/SuggestionItem.ts","../src/extensions/SlashMenu/BaseSlashMenuItem.ts","../src/extensions/SlashMenu/defaultSlashMenuItems.tsx","../src/extensions/TextAlignment/TextAlignmentExtension.ts","../src/extensions/TextColor/TextColorExtension.ts","../src/extensions/TextColor/TextColorMark.ts","../src/extensions/TrailingNode/TrailingNodeExtension.ts","../src/BlockNoteExtensions.ts","../src/BlockNoteEditor.ts"],"sourcesContent":["import { Attribute, Node } from \"@tiptap/core\";\nimport { BlockNoteEditor } from \"../../..\";\nimport styles from \"../nodes/Block.module.css\";\nimport {\n  BlockConfig,\n  BlockSchema,\n  BlockSpec,\n  PropSchema,\n  TipTapNode,\n  TipTapNodeConfig,\n} from \"./blockTypes\";\n\nexport function camelToDataKebab(str: string): string {\n  return \"data-\" + str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// Function that uses the 'propSchema' of a blockConfig to create a TipTap\n// node's `addAttributes` property.\nexport function propsToAttributes<\n  BType extends string,\n  PSchema extends PropSchema,\n  ContainsInlineContent extends boolean,\n  BSchema extends BlockSchema\n>(\n  blockConfig: Omit<\n    BlockConfig<BType, PSchema, ContainsInlineContent, BSchema>,\n    \"render\"\n  >\n) {\n  const tiptapAttributes: Record<string, Attribute> = {};\n\n  Object.entries(blockConfig.propSchema).forEach(([name, spec]) => {\n    tiptapAttributes[name] = {\n      default: spec.default,\n      keepOnSplit: true,\n      // Props are displayed in kebab-case as HTML attributes. If a prop's\n      // value is the same as its default, we don't display an HTML\n      // attribute for it.\n      parseHTML: (element) => element.getAttribute(camelToDataKebab(name)),\n      renderHTML: (attributes) =>\n        attributes[name] !== spec.default\n          ? {\n              [camelToDataKebab(name)]: attributes[name],\n            }\n          : {},\n    };\n  });\n\n  return tiptapAttributes;\n}\n\n// Function that uses the 'parse' function of a blockConfig to create a\n// TipTap node's `parseHTML` property. This is only used for parsing content\n// from the clipboard.\nexport function parse<\n  BType extends string,\n  PSchema extends PropSchema,\n  ContainsInlineContent extends boolean,\n  BSchema extends BlockSchema\n>(\n  blockConfig: Omit<\n    BlockConfig<BType, PSchema, ContainsInlineContent, BSchema>,\n    \"render\"\n  >\n) {\n  return [\n    {\n      tag: \"div[data-content-type=\" + blockConfig.type + \"]\",\n    },\n  ];\n}\n\n// Function that uses the 'render' function of a blockConfig to create a\n// TipTap node's `renderHTML` property. Since custom blocks use node views,\n// this is only used for serializing content to the clipboard.\nexport function render<\n  BType extends string,\n  PSchema extends PropSchema,\n  ContainsInlineContent extends boolean,\n  BSchema extends BlockSchema\n>(\n  blockConfig: Omit<\n    BlockConfig<BType, PSchema, ContainsInlineContent, BSchema>,\n    \"render\"\n  >,\n  HTMLAttributes: Record<string, any>\n) {\n  // Create blockContent element\n  const blockContent = document.createElement(\"div\");\n  // Add blockContent HTML attribute\n  blockContent.setAttribute(\"data-content-type\", blockConfig.type);\n  // Add props as HTML attributes in kebab-case with \"data-\" prefix\n  for (const [attribute, value] of Object.entries(HTMLAttributes)) {\n    blockContent.setAttribute(attribute, value);\n  }\n\n  // TODO: This only works for content copied within BlockNote.\n  // Creates contentDOM element to serialize inline content into.\n  let contentDOM: HTMLDivElement | undefined;\n  if (blockConfig.containsInlineContent) {\n    contentDOM = document.createElement(\"div\");\n    blockContent.appendChild(contentDOM);\n  } else {\n    contentDOM = undefined;\n  }\n\n  return contentDOM !== undefined\n    ? {\n        dom: blockContent,\n        contentDOM: contentDOM,\n      }\n    : {\n        dom: blockContent,\n      };\n}\n\n// A function to create custom block for API consumers\n// we want to hide the tiptap node from API consumers and provide a simpler API surface instead\nexport function createBlockSpec<\n  BType extends string,\n  PSchema extends PropSchema,\n  ContainsInlineContent extends boolean,\n  BSchema extends BlockSchema\n>(\n  blockConfig: BlockConfig<BType, PSchema, ContainsInlineContent, BSchema>\n): BlockSpec<BType, PSchema> {\n  const node = createTipTapBlock<BType>({\n    name: blockConfig.type,\n    content: blockConfig.containsInlineContent ? \"inline*\" : \"\",\n    selectable: blockConfig.containsInlineContent,\n\n    addOptions() {\n      return {\n        editor: undefined,\n      };\n    },\n\n    addAttributes() {\n      return propsToAttributes(blockConfig);\n    },\n\n    parseHTML() {\n      return parse(blockConfig);\n    },\n\n    renderHTML({ HTMLAttributes }) {\n      return render(blockConfig, HTMLAttributes);\n    },\n\n    addNodeView() {\n      return ({ HTMLAttributes, getPos }) => {\n        // Create blockContent element\n        const blockContent = document.createElement(\"div\");\n        // Sets blockContent class\n        blockContent.className = styles.blockContent;\n        // Add blockContent HTML attribute\n        blockContent.setAttribute(\"data-content-type\", blockConfig.type);\n        // Add props as HTML attributes in kebab-case with \"data-\" prefix\n        for (const [attribute, value] of Object.entries(HTMLAttributes)) {\n          blockContent.setAttribute(attribute, value);\n        }\n\n        // Gets BlockNote editor instance\n        const editor = this.options.editor! as BlockNoteEditor<\n          BSchema & { [k in BType]: BlockSpec<BType, PSchema> }\n        >;\n        // Gets position of the node\n        if (typeof getPos === \"boolean\") {\n          throw new Error(\n            \"Cannot find node position as getPos is a boolean, not a function.\"\n          );\n        }\n        const pos = getPos();\n        // Gets TipTap editor instance\n        const tipTapEditor = editor._tiptapEditor;\n        // Gets parent blockContainer node\n        const blockContainer = tipTapEditor.state.doc.resolve(pos!).node();\n        // Gets block identifier\n        const blockIdentifier = blockContainer.attrs.id;\n\n        // Get the block\n        const block = editor.getBlock(blockIdentifier)!;\n        if (block.type !== blockConfig.type) {\n          throw new Error(\"Block type does not match\");\n        }\n\n        // Render elements\n        const rendered = blockConfig.render(block as any, editor);\n        // Add inlineContent class to inline content\n        if (\"contentDOM\" in rendered) {\n          rendered.contentDOM.className = `${\n            rendered.contentDOM.className\n              ? rendered.contentDOM.className + \" \"\n              : \"\"\n          }${styles.inlineContent}`;\n        }\n        // Add elements to blockContent\n        blockContent.appendChild(rendered.dom);\n\n        return \"contentDOM\" in rendered\n          ? {\n              dom: blockContent,\n              contentDOM: rendered.contentDOM,\n            }\n          : {\n              dom: blockContent,\n            };\n      };\n    },\n  });\n\n  return {\n    node: node,\n    propSchema: blockConfig.propSchema,\n  };\n}\n\nexport function createTipTapBlock<Type extends string>(\n  config: TipTapNodeConfig<Type>\n): TipTapNode<Type> {\n  // Type cast is needed as Node.name is mutable, though there is basically no\n  // reason to change it after creation. Alternative is to wrap Node in a new\n  // class, which I don't think is worth it since we'd only be changing 1\n  // attribute to be read only.\n  return Node.create({\n    ...config,\n    group: \"blockContent\",\n  }) as TipTapNode<Type>;\n}\n","import { InputRule, mergeAttributes } from \"@tiptap/core\";\nimport { createTipTapBlock } from \"../../../api/block\";\nimport styles from \"../../Block.module.css\";\n\nexport const HeadingBlockContent = createTipTapBlock<\"heading\">({\n  name: \"heading\",\n  content: \"inline*\",\n\n  addAttributes() {\n    return {\n      level: {\n        default: \"1\",\n        // instead of \"level\" attributes, use \"data-level\"\n        parseHTML: (element) => element.getAttribute(\"data-level\"),\n        renderHTML: (attributes) => {\n          return {\n            \"data-level\": attributes.level,\n          };\n        },\n      },\n    };\n  },\n\n  addInputRules() {\n    return [\n      ...[\"1\", \"2\", \"3\"].map((level) => {\n        // Creates a heading of appropriate level when starting with \"#\", \"##\", or \"###\".\n        return new InputRule({\n          find: new RegExp(`^(#{${parseInt(level)}})\\\\s$`),\n          handler: ({ state, chain, range }) => {\n            chain()\n              .BNUpdateBlock(state.selection.from, {\n                type: \"heading\",\n                props: {\n                  level: level as \"1\" | \"2\" | \"3\",\n                },\n              })\n              // Removes the \"#\" character(s) used to set the heading.\n              .deleteRange({ from: range.from, to: range.to });\n          },\n        });\n      }),\n    ];\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"h1\",\n        attrs: { level: \"1\" },\n        node: \"heading\",\n      },\n      {\n        tag: \"h2\",\n        attrs: { level: \"2\" },\n        node: \"heading\",\n      },\n      {\n        tag: \"h3\",\n        attrs: { level: \"3\" },\n        node: \"heading\",\n      },\n    ];\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      [\"h\" + node.attrs.level, { class: styles.inlineContent }, 0],\n    ];\n  },\n});\n","import { Node, NodeType } from \"prosemirror-model\";\n\nexport type BlockInfo = {\n  id: string;\n  node: Node;\n  contentNode: Node;\n  contentType: NodeType;\n  numChildBlocks: number;\n  startPos: number;\n  endPos: number;\n  depth: number;\n};\n\n/**\n * Retrieves information regarding the most nested block node in a ProseMirror doc, that a given position lies in.\n * @param doc The ProseMirror doc.\n * @param posInBlock A position somewhere within a block node.\n * @returns A BlockInfo object for the block the given position is in, or undefined if the position is not in a block\n * for the given doc.\n */\nexport function getBlockInfoFromPos(\n  doc: Node,\n  posInBlock: number\n): BlockInfo | undefined {\n  if (posInBlock < 0 || posInBlock > doc.nodeSize) {\n    return undefined;\n  }\n\n  const $pos = doc.resolve(posInBlock);\n\n  const maxDepth = $pos.depth;\n  let node = $pos.node(maxDepth);\n  let depth = maxDepth;\n\n  while (true) {\n    if (depth < 0) {\n      return undefined;\n    }\n\n    if (node.type.name === \"blockContainer\") {\n      break;\n    }\n\n    depth -= 1;\n    node = $pos.node(depth);\n  }\n\n  const id = node.attrs[\"id\"];\n  const contentNode = node.firstChild!;\n  const contentType = contentNode.type;\n  const numChildBlocks = node.childCount === 2 ? node.lastChild!.childCount : 0;\n\n  const startPos = $pos.start(depth);\n  const endPos = $pos.end(depth);\n\n  return {\n    id,\n    node,\n    contentNode,\n    contentType,\n    numChildBlocks,\n    startPos,\n    endPos,\n    depth,\n  };\n}\n","import { Editor } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../../../helpers/getBlockInfoFromPos\";\n\nexport const handleEnter = (editor: Editor) => {\n  const { node, contentType } = getBlockInfoFromPos(\n    editor.state.doc,\n    editor.state.selection.from\n  )!;\n\n  const selectionEmpty =\n    editor.state.selection.anchor === editor.state.selection.head;\n\n  if (!contentType.name.endsWith(\"ListItem\") || !selectionEmpty) {\n    return false;\n  }\n\n  return editor.commands.first(({ state, chain, commands }) => [\n    () =>\n      // Changes list item block to a text block if the content is empty.\n      commands.command(() => {\n        if (node.textContent.length === 0) {\n          return commands.BNUpdateBlock(state.selection.from, {\n            type: \"paragraph\",\n            props: {},\n          });\n        }\n\n        return false;\n      }),\n\n    () =>\n      // Splits the current block, moving content inside that's after the cursor to a new block of the same type\n      // below.\n      commands.command(() => {\n        if (node.textContent.length > 0) {\n          chain()\n            .deleteSelection()\n            .BNSplitBlock(state.selection.from, true)\n            .run();\n\n          return true;\n        }\n\n        return false;\n      }),\n  ]);\n};\n","import { InputRule, mergeAttributes } from \"@tiptap/core\";\nimport { createTipTapBlock } from \"../../../../api/block\";\nimport { handleEnter } from \"../ListItemKeyboardShortcuts\";\nimport styles from \"../../../Block.module.css\";\n\nexport const BulletListItemBlockContent = createTipTapBlock<\"bulletListItem\">({\n  name: \"bulletListItem\",\n  content: \"inline*\",\n\n  addInputRules() {\n    return [\n      // Creates an unordered list when starting with \"-\", \"+\", or \"*\".\n      new InputRule({\n        find: new RegExp(`^[-+*]\\\\s$`),\n        handler: ({ state, chain, range }) => {\n          chain()\n            .BNUpdateBlock(state.selection.from, {\n              type: \"bulletListItem\",\n              props: {},\n            })\n            // Removes the \"-\", \"+\", or \"*\" character used to set the list.\n            .deleteRange({ from: range.from, to: range.to });\n        },\n      }),\n    ];\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => handleEnter(this.editor),\n    };\n  },\n\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      {\n        tag: \"li\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.tagName === \"UL\") {\n            return {};\n          }\n\n          return false;\n        },\n        node: \"bulletListItem\",\n      },\n      // Case for BlockNote list structure.\n      {\n        tag: \"p\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const parent = element.parentElement;\n\n          if (parent === null) {\n            return false;\n          }\n\n          if (parent.getAttribute(\"data-content-type\") === \"bulletListItem\") {\n            return {};\n          }\n\n          return false;\n        },\n        priority: 300,\n        node: \"bulletListItem\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      [\"p\", { class: styles.inlineContent }, 0],\n    ];\n  },\n});\n","import { Plugin, PluginKey } from \"prosemirror-state\";\nimport { getBlockInfoFromPos } from \"../../../../helpers/getBlockInfoFromPos\";\n\n// ProseMirror Plugin which automatically assigns indices to ordered list items per nesting level.\nconst PLUGIN_KEY = new PluginKey(`numbered-list-indexing`);\nexport const NumberedListIndexingPlugin = () => {\n  return new Plugin({\n    key: PLUGIN_KEY,\n    appendTransaction: (_transactions, _oldState, newState) => {\n      const tr = newState.tr;\n      tr.setMeta(\"numberedListIndexing\", true);\n\n      let modified = false;\n\n      // Traverses each node the doc using DFS, so blocks which are on the same nesting level will be traversed in the\n      // same order they appear. This means the index of each list item block can be calculated by incrementing the\n      // index of the previous list item block.\n      newState.doc.descendants((node, pos) => {\n        if (\n          node.type.name === \"blockContainer\" &&\n          node.firstChild!.type.name === \"numberedListItem\"\n        ) {\n          let newIndex = \"1\";\n          const isFirstBlockInDoc = pos === 1;\n\n          const blockInfo = getBlockInfoFromPos(tr.doc, pos + 1)!;\n          if (blockInfo === undefined) {\n            return;\n          }\n\n          // Checks if this block is the start of a new ordered list, i.e. if it's the first block in the document, the\n          // first block in its nesting level, or the previous block is not an ordered list item.\n          if (!isFirstBlockInDoc) {\n            const prevBlockInfo = getBlockInfoFromPos(tr.doc, pos - 2)!;\n            if (prevBlockInfo === undefined) {\n              return;\n            }\n\n            const isFirstBlockInNestingLevel =\n              blockInfo.depth !== prevBlockInfo.depth;\n\n            if (!isFirstBlockInNestingLevel) {\n              const prevBlockContentNode = prevBlockInfo.contentNode;\n              const prevBlockContentType = prevBlockInfo.contentType;\n\n              const isPrevBlockOrderedListItem =\n                prevBlockContentType.name === \"numberedListItem\";\n\n              if (isPrevBlockOrderedListItem) {\n                const prevBlockIndex = prevBlockContentNode.attrs[\"index\"];\n\n                newIndex = (parseInt(prevBlockIndex) + 1).toString();\n              }\n            }\n          }\n\n          const contentNode = blockInfo.contentNode;\n          const index = contentNode.attrs[\"index\"];\n\n          if (index !== newIndex) {\n            modified = true;\n\n            tr.setNodeMarkup(pos + 1, undefined, {\n              index: newIndex,\n            });\n          }\n        }\n      });\n\n      return modified ? tr : null;\n    },\n  });\n};\n","import { InputRule, mergeAttributes } from \"@tiptap/core\";\nimport { createTipTapBlock } from \"../../../../api/block\";\nimport { handleEnter } from \"../ListItemKeyboardShortcuts\";\nimport { NumberedListIndexingPlugin } from \"./NumberedListIndexingPlugin\";\nimport styles from \"../../../Block.module.css\";\n\nexport const NumberedListItemBlockContent =\n  createTipTapBlock<\"numberedListItem\">({\n    name: \"numberedListItem\",\n    content: \"inline*\",\n\n    addAttributes() {\n      return {\n        index: {\n          default: null,\n          parseHTML: (element) => element.getAttribute(\"data-index\"),\n          renderHTML: (attributes) => {\n            return {\n              \"data-index\": attributes.index,\n            };\n          },\n        },\n      };\n    },\n\n    addInputRules() {\n      return [\n        // Creates an ordered list when starting with \"1.\".\n        new InputRule({\n          find: new RegExp(`^1\\\\.\\\\s$`),\n          handler: ({ state, chain, range }) => {\n            chain()\n              .BNUpdateBlock(state.selection.from, {\n                type: \"numberedListItem\",\n                props: {},\n              })\n              // Removes the \"1.\" characters used to set the list.\n              .deleteRange({ from: range.from, to: range.to });\n          },\n        }),\n      ];\n    },\n\n    addKeyboardShortcuts() {\n      return {\n        Enter: () => handleEnter(this.editor),\n      };\n    },\n\n    addProseMirrorPlugins() {\n      return [NumberedListIndexingPlugin()];\n    },\n\n    parseHTML() {\n      return [\n        // Case for regular HTML list structure.\n        // (e.g.: when pasting from other apps)\n        {\n          tag: \"li\",\n          getAttrs: (element) => {\n            if (typeof element === \"string\") {\n              return false;\n            }\n\n            const parent = element.parentElement;\n\n            if (parent === null) {\n              return false;\n            }\n\n            if (parent.tagName === \"OL\") {\n              return {};\n            }\n\n            return false;\n          },\n          node: \"numberedListItem\",\n        },\n        // Case for BlockNote list structure.\n        // (e.g.: when pasting from blocknote)\n        {\n          tag: \"p\",\n          getAttrs: (element) => {\n            if (typeof element === \"string\") {\n              return false;\n            }\n\n            const parent = element.parentElement;\n\n            if (parent === null) {\n              return false;\n            }\n\n            if (\n              parent.getAttribute(\"data-content-type\") === \"numberedListItem\"\n            ) {\n              return {};\n            }\n\n            return false;\n          },\n          priority: 300,\n          node: \"numberedListItem\",\n        },\n      ];\n    },\n\n    renderHTML({ HTMLAttributes }) {\n      return [\n        \"div\",\n        mergeAttributes(HTMLAttributes, {\n          class: styles.blockContent,\n          \"data-content-type\": this.name,\n        }),\n        // we use a <p> tag, because for <li> tags we'd need to add a <ul> parent for around siblings to be semantically correct,\n        // which would be quite cumbersome\n        [\"p\", { class: styles.inlineContent }, 0],\n      ];\n    },\n  });\n","import { mergeAttributes } from \"@tiptap/core\";\nimport { createTipTapBlock } from \"../../../api/block\";\nimport styles from \"../../Block.module.css\";\n\nexport const ParagraphBlockContent = createTipTapBlock<\"paragraph\">({\n  name: \"paragraph\",\n  content: \"inline*\",\n\n  parseHTML() {\n    return [\n      {\n        tag: \"p\",\n        priority: 200,\n        node: \"paragraph\",\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockContent,\n        \"data-content-type\": this.name,\n      }),\n      [\"p\", { class: styles.inlineContent }, 0],\n    ];\n  },\n});\n","import { HeadingBlockContent } from \"../nodes/BlockContent/HeadingBlockContent/HeadingBlockContent\";\nimport { BulletListItemBlockContent } from \"../nodes/BlockContent/ListItemBlockContent/BulletListItemBlockContent/BulletListItemBlockContent\";\nimport { NumberedListItemBlockContent } from \"../nodes/BlockContent/ListItemBlockContent/NumberedListItemBlockContent/NumberedListItemBlockContent\";\nimport { ParagraphBlockContent } from \"../nodes/BlockContent/ParagraphBlockContent/ParagraphBlockContent\";\nimport { PropSchema, TypesMatch } from \"./blockTypes\";\n\nexport const defaultProps = {\n  backgroundColor: {\n    default: \"transparent\" as const,\n  },\n  textColor: {\n    default: \"black\" as const, // TODO\n  },\n  textAlignment: {\n    default: \"left\" as const,\n    values: [\"left\", \"center\", \"right\", \"justify\"] as const,\n  },\n} satisfies PropSchema;\n\nexport type DefaultProps = typeof defaultProps;\n\nexport const defaultBlockSchema = {\n  paragraph: {\n    propSchema: defaultProps,\n    node: ParagraphBlockContent,\n  },\n  heading: {\n    propSchema: {\n      ...defaultProps,\n      level: { default: \"1\", values: [\"1\", \"2\", \"3\"] as const },\n    },\n    node: HeadingBlockContent,\n  },\n  bulletListItem: {\n    propSchema: defaultProps,\n    node: BulletListItemBlockContent,\n  },\n  numberedListItem: {\n    propSchema: defaultProps,\n    node: NumberedListItemBlockContent,\n  },\n} as const;\n\nexport type DefaultBlockSchema = TypesMatch<typeof defaultBlockSchema>;\n","import {\n  combineTransactionSteps,\n  Extension,\n  findChildren,\n  findChildrenInRange,\n  getChangedRanges,\n} from \"@tiptap/core\";\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { v4 } from \"uuid\";\n\n/**\n * Code from Tiptap UniqueID extension (https://tiptap.dev/api/extensions/unique-id)\n * This extension is licensed under MIT (even though it's part of Tiptap pro).\n *\n * If you're a user of BlockNote, we still recommend to support their awesome work and become a sponsor!\n * https://tiptap.dev/pro\n */\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array: any, by = JSON.stringify) {\n  const seen: any = {};\n  return array.filter((item: any) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key)\n      ? false\n      : (seen[key] = true);\n  });\n}\n\n/**\n * Returns a list of duplicated items within an array.\n */\nfunction findDuplicates(items: any) {\n  const filtered = items.filter(\n    (el: any, index: number) => items.indexOf(el) !== index\n  );\n  const duplicates = removeDuplicates(filtered);\n  return duplicates;\n}\n\nconst UniqueID = Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 10000,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      generateID: () => {\n        // Use mock ID if tests are running.\n        if ((window as any).__TEST_OPTIONS) {\n          if ((window as any).__TEST_OPTIONS.mockID === undefined) {\n            (window as any).__TEST_OPTIONS.mockID = 0;\n          } else {\n            (window as any).__TEST_OPTIONS.mockID++;\n          }\n\n          return (window as any).__TEST_OPTIONS.mockID.toString() as string;\n        }\n\n        return v4();\n      },\n      filterTransaction: null,\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (element) =>\n              element.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (attributes) => ({\n              [`data-${this.options.attributeName}`]:\n                attributes[this.options.attributeName],\n            }),\n          },\n        },\n      },\n    ];\n  },\n  // check initial content for missing ids\n  onCreate() {\n    // Don’t do this when the collaboration extension is active\n    // because this may update the content, so Y.js tries to merge these changes.\n    // This leads to empty block nodes.\n    // See: https://github.com/ueberdosis/tiptap/issues/2400\n    if (\n      this.editor.extensionManager.extensions.find(\n        (extension) => extension.name === \"collaboration\"\n      )\n    ) {\n      return;\n    }\n    const { view, state } = this.editor;\n    const { tr, doc } = state;\n    const { types, attributeName, generateID } = this.options;\n    const nodesWithoutId = findChildren(doc, (node) => {\n      return (\n        types.includes(node.type.name) && node.attrs[attributeName] === null\n      );\n    });\n    nodesWithoutId.forEach(({ node, pos }) => {\n      tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        [attributeName]: generateID(),\n      });\n    });\n    tr.setMeta(\"addToHistory\", false);\n    view.dispatch(tr);\n  },\n  addProseMirrorPlugins() {\n    let dragSourceElement: any = null;\n    let transformPasted = false;\n    return [\n      new Plugin({\n        key: new PluginKey(\"uniqueID\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          // console.log(\"appendTransaction\");\n          const docChanges =\n            transactions.some((transaction) => transaction.docChanged) &&\n            !oldState.doc.eq(newState.doc);\n          const filterTransactions =\n            this.options.filterTransaction &&\n            transactions.some((tr) => {\n              var _a, _b;\n              return !((_b = (_a = this.options).filterTransaction) === null ||\n              _b === void 0\n                ? void 0\n                : _b.call(_a, tr));\n            });\n          if (!docChanges || filterTransactions) {\n            return;\n          }\n          const { tr } = newState;\n          const { types, attributeName, generateID } = this.options;\n          const transform = combineTransactionSteps(\n            oldState.doc,\n            transactions as any\n          );\n          const { mapping } = transform;\n          // get changed ranges based on the old state\n          const changes = getChangedRanges(transform);\n\n          changes.forEach(({ newRange }) => {\n            const newNodes = findChildrenInRange(\n              newState.doc,\n              newRange,\n              (node) => {\n                return types.includes(node.type.name);\n              }\n            );\n            const newIds = newNodes\n              .map(({ node }) => node.attrs[attributeName])\n              .filter((id) => id !== null);\n            const duplicatedNewIds = findDuplicates(newIds);\n            newNodes.forEach(({ node, pos }) => {\n              var _a;\n              // instead of checking `node.attrs[attributeName]` directly\n              // we look at the current state of the node within `tr.doc`.\n              // this helps to prevent adding new ids to the same node\n              // if the node changed multiple times within one transaction\n              const id =\n                (_a = tr.doc.nodeAt(pos)) === null || _a === void 0\n                  ? void 0\n                  : _a.attrs[attributeName];\n              if (id === null) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n                return;\n              }\n              // check if the node doesn’t exist in the old state\n              const { deleted } = mapping.invert().mapResult(pos);\n              const newNode = deleted && duplicatedNewIds.includes(id);\n              if (newNode) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  [attributeName]: generateID(),\n                });\n              }\n            });\n          });\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(view) {\n          const handleDragstart = (event: any) => {\n            var _a;\n            dragSourceElement = (\n              (_a = view.dom.parentElement) === null || _a === void 0\n                ? void 0\n                : _a.contains(event.target)\n            )\n              ? view.dom.parentElement\n              : null;\n          };\n          window.addEventListener(\"dragstart\", handleDragstart);\n          return {\n            destroy() {\n              window.removeEventListener(\"dragstart\", handleDragstart);\n            },\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (view, event: any) => {\n              var _a;\n              if (\n                dragSourceElement !== view.dom.parentElement ||\n                ((_a = event.dataTransfer) === null || _a === void 0\n                  ? void 0\n                  : _a.effectAllowed) === \"copy\"\n              ) {\n                dragSourceElement = null;\n                transformPasted = true;\n              }\n              return false;\n            },\n            // always create new ids on pasted content\n            paste: () => {\n              transformPasted = true;\n              return false;\n            },\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (slice) => {\n            if (!transformPasted) {\n              return slice;\n            }\n            const { types, attributeName } = this.options;\n            const removeId = (fragment: any) => {\n              const list: any[] = [];\n              fragment.forEach((node: any) => {\n                // don’t touch text nodes\n                if (node.isText) {\n                  list.push(node);\n                  return;\n                }\n                // check for any other child nodes\n                if (!types.includes(node.type.name)) {\n                  list.push(node.copy(removeId(node.content)));\n                  return;\n                }\n                // remove id\n                const nodeWithoutId = node.type.create(\n                  {\n                    ...node.attrs,\n                    [attributeName]: null,\n                  },\n                  removeId(node.content),\n                  node.marks\n                );\n                list.push(nodeWithoutId);\n              });\n              return Fragment.from(list);\n            };\n            // reset check\n            transformPasted = false;\n            return new Slice(\n              removeId(slice.content),\n              slice.openStart,\n              slice.openEnd\n            );\n          },\n        },\n      }),\n    ];\n  },\n});\n\nexport { UniqueID, UniqueID as default };\n//# sourceMappingURL=tiptap-extension-unique-id.esm.js.map\n","export const isAppleOS = () =>\n  /Mac/.test(navigator.platform) ||\n  (/AppleWebKit/.test(navigator.userAgent) &&\n    /Mobile\\/\\w+/.test(navigator.userAgent));\n\nexport function formatKeyboardShortcut(shortcut: string) {\n  if (isAppleOS()) {\n    return shortcut.replace(\"Mod\", \"⌘\");\n  } else {\n    return shortcut.replace(\"Mod\", \"Ctrl\");\n  }\n}\n\nexport class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n","import { Mark } from \"@tiptap/pm/model\";\nimport { Node, Schema } from \"prosemirror-model\";\nimport {\n  Block,\n  BlockSchema,\n  PartialBlock,\n} from \"../../extensions/Blocks/api/blockTypes\";\n\nimport { defaultProps } from \"../../extensions/Blocks/api/defaultBlocks\";\nimport {\n  ColorStyle,\n  InlineContent,\n  PartialInlineContent,\n  PartialLink,\n  StyledText,\n  Styles,\n  ToggledStyle,\n} from \"../../extensions/Blocks/api/inlineContentTypes\";\nimport { getBlockInfoFromPos } from \"../../extensions/Blocks/helpers/getBlockInfoFromPos\";\nimport UniqueID from \"../../extensions/UniqueID/UniqueID\";\nimport { UnreachableCaseError } from \"../../shared/utils\";\n\nconst toggleStyles = new Set<ToggledStyle>([\n  \"bold\",\n  \"italic\",\n  \"underline\",\n  \"strike\",\n  \"code\",\n]);\nconst colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n/**\n * Convert a StyledText inline element to a\n * prosemirror text node with the appropriate marks\n */\nfunction styledTextToNodes(styledText: StyledText, schema: Schema): Node[] {\n  const marks: Mark[] = [];\n\n  for (const [style, value] of Object.entries(styledText.styles)) {\n    if (toggleStyles.has(style as ToggledStyle)) {\n      marks.push(schema.mark(style));\n    } else if (colorStyles.has(style as ColorStyle)) {\n      marks.push(schema.mark(style, { color: value }));\n    }\n  }\n\n  return (\n    styledText.text\n      // Splits text & line breaks.\n      .split(/(\\n)/g)\n      // If the content ends with a line break, an empty string is added to the\n      // end, which this removes.\n      .filter((text) => text.length > 0)\n      // Converts text & line breaks to nodes.\n      .map((text) => {\n        if (text === \"\\n\") {\n          return schema.nodes[\"hardBreak\"].create();\n        } else {\n          return schema.text(text, marks);\n        }\n      })\n  );\n}\n\n/**\n * Converts a Link inline content element to\n * prosemirror text nodes with the appropriate marks\n */\nfunction linkToNodes(link: PartialLink, schema: Schema): Node[] {\n  const linkMark = schema.marks.link.create({\n    href: link.href,\n  });\n\n  return styledTextArrayToNodes(link.content, schema).map((node) => {\n    if (node.type.name === \"text\") {\n      return node.mark([...node.marks, linkMark]);\n    }\n\n    if (node.type.name === \"hardBreak\") {\n      return node;\n    }\n    throw new Error(\"unexpected node type\");\n  });\n}\n\n/**\n * Converts an array of StyledText inline content elements to\n * prosemirror text nodes with the appropriate marks\n */\nfunction styledTextArrayToNodes(\n  content: string | StyledText[],\n  schema: Schema\n): Node[] {\n  let nodes: Node[] = [];\n\n  if (typeof content === \"string\") {\n    nodes.push(\n      ...styledTextToNodes({ type: \"text\", text: content, styles: {} }, schema)\n    );\n    return nodes;\n  }\n\n  for (const styledText of content) {\n    nodes.push(...styledTextToNodes(styledText, schema));\n  }\n  return nodes;\n}\n\n/**\n * converts an array of inline content elements to prosemirror nodes\n */\nexport function inlineContentToNodes(\n  blockContent: PartialInlineContent[],\n  schema: Schema\n): Node[] {\n  let nodes: Node[] = [];\n\n  for (const content of blockContent) {\n    if (content.type === \"link\") {\n      nodes.push(...linkToNodes(content, schema));\n    } else if (content.type === \"text\") {\n      nodes.push(...styledTextArrayToNodes([content], schema));\n    } else {\n      throw new UnreachableCaseError(content);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Converts a BlockNote block to a TipTap node.\n */\nexport function blockToNode<BSchema extends BlockSchema>(\n  block: PartialBlock<BSchema>,\n  schema: Schema\n) {\n  let id = block.id;\n\n  if (id === undefined) {\n    id = UniqueID.options.generateID();\n  }\n\n  let type = block.type;\n\n  if (type === undefined) {\n    type = \"paragraph\";\n  }\n\n  let contentNode: Node;\n\n  if (!block.content) {\n    contentNode = schema.nodes[type].create(block.props);\n  } else if (typeof block.content === \"string\") {\n    contentNode = schema.nodes[type].create(\n      block.props,\n      schema.text(block.content)\n    );\n  } else {\n    const nodes = inlineContentToNodes(block.content, schema);\n    contentNode = schema.nodes[type].create(block.props, nodes);\n  }\n\n  const children: Node[] = [];\n\n  if (block.children) {\n    for (const child of block.children) {\n      children.push(blockToNode(child, schema));\n    }\n  }\n\n  const groupNode = schema.nodes[\"blockGroup\"].create({}, children);\n\n  return schema.nodes[\"blockContainer\"].create(\n    {\n      id: id,\n      ...block.props,\n    },\n    children.length > 0 ? [contentNode, groupNode] : contentNode\n  );\n}\n\n/**\n * Converts an internal (prosemirror) content node to a BlockNote InlineContent array.\n */\nfunction contentNodeToInlineContent(contentNode: Node) {\n  const content: InlineContent[] = [];\n  let currentContent: InlineContent | undefined = undefined;\n\n  // Most of the logic below is for handling links because in ProseMirror links are marks\n  // while in BlockNote links are a type of inline content\n  contentNode.content.forEach((node) => {\n    // hardBreak nodes do not have an InlineContent equivalent, instead we\n    // add a newline to the previous node.\n    if (node.type.name === \"hardBreak\") {\n      if (currentContent) {\n        // Current content exists.\n        if (currentContent.type === \"text\") {\n          // Current content is text.\n          currentContent.text += \"\\n\";\n        } else if (currentContent.type === \"link\") {\n          // Current content is a link.\n          currentContent.content[currentContent.content.length - 1].text +=\n            \"\\n\";\n        }\n      } else {\n        // Current content does not exist.\n        currentContent = {\n          type: \"text\",\n          text: \"\\n\",\n          styles: {},\n        };\n      }\n\n      return;\n    }\n\n    const styles: Styles = {};\n    let linkMark: Mark | undefined;\n    let commentMark: Mark | undefined;\n\n    for (const mark of node.marks) {\n      if (mark.type.name === \"link\") {\n        linkMark = mark;\n      } else if (mark.type.name === \"comment\") {\n        commentMark = mark;\n      } else if (toggleStyles.has(mark.type.name as ToggledStyle)) {\n        styles[mark.type.name as ToggledStyle] = true;\n      } else if (colorStyles.has(mark.type.name as ColorStyle)) {\n        styles[mark.type.name as ColorStyle] = mark.attrs.color;\n      } else {\n        throw Error(\"Mark is of an unrecognized type: \" + mark.type.name);\n      }\n    }\n\n    // Parsing links and text.\n    // Current content exists.\n    if (currentContent) {\n      // Current content is text.\n      if (currentContent.type === \"text\") {\n        if (linkMark) {\n          // Node is a link (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"link\",\n            href: linkMark.attrs.href,\n            content: [\n              {\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              },\n            ],\n          };\n        } else if (commentMark) {\n          content.push(currentContent);\n        } else {\n          // Node is text (same type as current content).\n          if (\n            JSON.stringify(currentContent.styles) === JSON.stringify(styles)\n          ) {\n            // Styles are the same.\n            currentContent.text += node.textContent;\n          } else {\n            // Styles are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            };\n          }\n        }\n      } else if (currentContent.type === \"link\") {\n        // Current content is a link.\n        if (linkMark) {\n          // Node is a link (same type as current content).\n          // Link URLs are the same.\n          if (currentContent.href === linkMark.attrs.href) {\n            // Styles are the same.\n            if (\n              JSON.stringify(\n                currentContent.content[currentContent.content.length - 1].styles\n              ) === JSON.stringify(styles)\n            ) {\n              currentContent.content[currentContent.content.length - 1].text +=\n                node.textContent;\n            } else {\n              // Styles are different.\n              currentContent.content.push({\n                type: \"text\",\n                text: node.textContent,\n                styles,\n              });\n            }\n          } else {\n            // Link URLs are different.\n            content.push(currentContent);\n            currentContent = {\n              type: \"link\",\n              href: linkMark.attrs.href,\n              content: [\n                {\n                  type: \"text\",\n                  text: node.textContent,\n                  styles,\n                },\n              ],\n            };\n          }\n        } else {\n          // Node is text (different type to current content).\n          content.push(currentContent);\n          currentContent = {\n            type: \"text\",\n            text: node.textContent,\n            styles,\n          };\n        }\n      }\n    }\n    // Current content does not exist.\n    else {\n      // Node is text.\n      if (!linkMark) {\n        currentContent = {\n          type: \"text\",\n          text: node.textContent,\n          styles,\n        };\n      }\n      // Node is a link.\n      else {\n        currentContent = {\n          type: \"link\",\n          href: linkMark.attrs.href,\n          content: [\n            {\n              type: \"text\",\n              text: node.textContent,\n              styles,\n            },\n          ],\n        };\n      }\n    }\n  });\n\n  if (currentContent) {\n    content.push(currentContent);\n  }\n\n  return content;\n}\n\n/**\n * Convert a TipTap node to a BlockNote block.\n */\nexport function nodeToBlock<BSchema extends BlockSchema>(\n  node: Node,\n  blockSchema: BSchema,\n  blockCache?: WeakMap<Node, Block<BSchema>>\n): Block<BSchema> {\n  if (node.type.name !== \"blockContainer\") {\n    throw Error(\n      \"Node must be of type blockContainer, but is of type\" +\n        node.type.name +\n        \".\"\n    );\n  }\n\n  const cachedBlock = blockCache?.get(node);\n\n  if (cachedBlock) {\n    return cachedBlock;\n  }\n\n  const blockInfo = getBlockInfoFromPos(node, 0)!;\n\n  let id = blockInfo.id;\n\n  // Only used for blocks converted from other formats.\n  if (id === null) {\n    id = UniqueID.options.generateID();\n  }\n\n  const props: any = {};\n  for (const [attr, value] of Object.entries({\n    ...blockInfo.node.attrs,\n    ...blockInfo.contentNode.attrs,\n  })) {\n    const blockSpec = blockSchema[blockInfo.contentType.name];\n    if (!blockSpec) {\n      throw Error(\n        \"Block is of an unrecognized type: \" + blockInfo.contentType.name\n      );\n    }\n\n    const propSchema = blockSpec.propSchema;\n\n    if (attr in propSchema) {\n      props[attr] = value;\n    }\n    // Block ids are stored as node attributes the same way props are, so we\n    // need to ensure we don't attempt to read block ids as props.\n\n    // the second check is for the backgroundColor & textColor props.\n    // Since we want them to be inherited by child blocks, we can't put them on the blockContent node,\n    // and instead have to put them on the blockContainer node.\n    // The blockContainer node is the same for all block types, but some custom blocks might not use backgroundColor & textColor,\n    // so these 2 props are technically unexpected but we shouldn't log a warning.\n    // (this is a bit hacky)\n    else if (attr !== \"id\" && !(attr in defaultProps)) {\n      console.warn(\"Block has an unrecognized attribute: \" + attr);\n    }\n  }\n\n  const content = contentNodeToInlineContent(blockInfo.contentNode);\n\n  const children: Block<BSchema>[] = [];\n  for (let i = 0; i < blockInfo.numChildBlocks; i++) {\n    children.push(\n      nodeToBlock(blockInfo.node.lastChild!.child(i), blockSchema, blockCache)\n    );\n  }\n\n  const block: Block<BSchema> = {\n    id,\n    type: blockInfo.contentType.name,\n    props,\n    content,\n    children,\n  };\n\n  blockCache?.set(node, block);\n\n  return block;\n}\n","import { Node } from \"prosemirror-model\";\n\n/**\n * Get a TipTap node by id\n */\nexport function getNodeById(\n  id: string,\n  doc: Node\n): { node: Node; posBeforeNode: number } {\n  let targetNode: Node | undefined = undefined;\n  let posBeforeNode: number | undefined = undefined;\n\n  doc.firstChild!.descendants((node, pos) => {\n    // Skips traversing nodes after node with target ID has been found.\n    if (targetNode) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (node.type.name !== \"blockContainer\" || node.attrs.id !== id) {\n      return true;\n    }\n\n    targetNode = node;\n    posBeforeNode = pos + 1;\n\n    return false;\n  });\n\n  if (targetNode === undefined || posBeforeNode === undefined) {\n    throw Error(\"Could not find block in the editor with matching ID.\");\n  }\n\n  return {\n    node: targetNode,\n    posBeforeNode: posBeforeNode,\n  };\n}\n","import { Editor } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\nimport {\n  BlockIdentifier,\n  BlockSchema,\n  PartialBlock,\n} from \"../../extensions/Blocks/api/blockTypes\";\nimport { blockToNode } from \"../nodeConversions/nodeConversions\";\nimport { getNodeById } from \"../util/nodeUtil\";\n\nexport function insertBlocks<BSchema extends BlockSchema>(\n  blocksToInsert: PartialBlock<BSchema>[],\n  referenceBlock: BlockIdentifier,\n  placement: \"before\" | \"after\" | \"nested\" = \"before\",\n  editor: Editor\n): void {\n  const id =\n    typeof referenceBlock === \"string\" ? referenceBlock : referenceBlock.id;\n\n  const nodesToInsert: Node[] = [];\n  for (const blockSpec of blocksToInsert) {\n    nodesToInsert.push(blockToNode(blockSpec, editor.schema));\n  }\n\n  let insertionPos = -1;\n\n  const { node, posBeforeNode } = getNodeById(id, editor.state.doc);\n\n  if (placement === \"before\") {\n    insertionPos = posBeforeNode;\n  }\n\n  if (placement === \"after\") {\n    insertionPos = posBeforeNode + node.nodeSize;\n  }\n\n  if (placement === \"nested\") {\n    // Case if block doesn't already have children.\n    if (node.childCount < 2) {\n      insertionPos = posBeforeNode + node.firstChild!.nodeSize + 1;\n\n      const blockGroupNode = editor.state.schema.nodes[\"blockGroup\"].create(\n        {},\n        nodesToInsert\n      );\n\n      editor.view.dispatch(\n        editor.state.tr.insert(insertionPos, blockGroupNode)\n      );\n\n      return;\n    }\n\n    insertionPos = posBeforeNode + node.firstChild!.nodeSize + 2;\n  }\n\n  editor.view.dispatch(editor.state.tr.insert(insertionPos, nodesToInsert));\n}\n\nexport function updateBlock<BSchema extends BlockSchema>(\n  blockToUpdate: BlockIdentifier,\n  update: PartialBlock<BSchema>,\n  editor: Editor\n) {\n  const id =\n    typeof blockToUpdate === \"string\" ? blockToUpdate : blockToUpdate.id;\n  const { posBeforeNode } = getNodeById(id, editor.state.doc);\n\n  editor.commands.BNUpdateBlock(posBeforeNode + 1, update);\n}\n\nexport function removeBlocks(\n  blocksToRemove: BlockIdentifier[],\n  editor: Editor\n) {\n  const idsOfBlocksToRemove = new Set<string>(\n    blocksToRemove.map((block) =>\n      typeof block === \"string\" ? block : block.id\n    )\n  );\n\n  let removedSize = 0;\n\n  editor.state.doc.descendants((node, pos) => {\n    // Skips traversing nodes after all target blocks have been removed.\n    if (idsOfBlocksToRemove.size === 0) {\n      return false;\n    }\n\n    // Keeps traversing nodes if block with target ID has not been found.\n    if (\n      node.type.name !== \"blockContainer\" ||\n      !idsOfBlocksToRemove.has(node.attrs.id)\n    ) {\n      return true;\n    }\n\n    idsOfBlocksToRemove.delete(node.attrs.id);\n    const oldDocSize = editor.state.doc.nodeSize;\n\n    editor.commands.BNDeleteBlock(pos - removedSize + 1);\n\n    const newDocSize = editor.state.doc.nodeSize;\n    removedSize += oldDocSize - newDocSize;\n\n    return false;\n  });\n\n  if (idsOfBlocksToRemove.size > 0) {\n    let notFoundIds = [...idsOfBlocksToRemove].join(\"\\n\");\n\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" +\n        notFoundIds\n    );\n  }\n}\n\nexport function replaceBlocks<BSchema extends BlockSchema>(\n  blocksToRemove: BlockIdentifier[],\n  blocksToInsert: PartialBlock<BSchema>[],\n  editor: Editor\n) {\n  insertBlocks(blocksToInsert, blocksToRemove[0], \"before\", editor);\n  removeBlocks(blocksToRemove, editor);\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\n\n/**\n * Rehype plugin which removes <u> tags. Used to remove underlines before converting HTML to markdown, as Markdown\n * doesn't support underlines.\n */\nexport function removeUnderlines() {\n  const removeUnderlinesHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const node = tree.children[i];\n\n      if (node.type === \"element\") {\n        // Recursively removes underlines from child elements.\n        removeUnderlinesHelper(node);\n\n        if ((node as HASTElement).tagName === \"u\") {\n          // Lifts child nodes outside underline element, deletes the underline element, and updates current index &\n          // the number of child elements.\n          if (node.children.length > 0) {\n            tree.children.splice(i, 1, ...node.children);\n\n            const numElementsAdded = node.children.length - 1;\n            numChildElements += numElementsAdded;\n            i += numElementsAdded;\n          } else {\n            tree.children.splice(i, 1);\n\n            numChildElements--;\n            i--;\n          }\n        }\n      }\n    }\n  };\n\n  return removeUnderlinesHelper;\n}\n","import { Element as HASTElement, Parent as HASTParent } from \"hast\";\nimport { fromDom } from \"hast-util-from-dom\";\n\ntype SimplifyBlocksOptions = {\n  orderedListItemBlockTypes: Set<string>;\n  unorderedListItemBlockTypes: Set<string>;\n};\n\n/**\n * Rehype plugin which converts the HTML output string rendered by BlockNote into a simplified structure which better\n * follows HTML standards. It does several things:\n * - Removes all block related div elements, leaving only the actual content inside the block.\n * - Lifts nested blocks to a higher level for all block types that don't represent list items.\n * - Wraps blocks which represent list items in corresponding ul/ol HTML elements and restructures them to comply\n * with HTML list structure.\n * @param options Options for specifying which block types represent ordered and unordered list items.\n */\nexport function simplifyBlocks(options: SimplifyBlocksOptions) {\n  const listItemBlockTypes = new Set<string>([\n    ...options.orderedListItemBlockTypes,\n    ...options.unorderedListItemBlockTypes,\n  ]);\n\n  const simplifyBlocksHelper = (tree: HASTParent) => {\n    let numChildElements = tree.children.length;\n    let activeList: HASTElement | undefined;\n\n    for (let i = 0; i < numChildElements; i++) {\n      const blockOuter = tree.children[i] as HASTElement;\n      const blockContainer = blockOuter.children[0] as HASTElement;\n      const blockContent = blockContainer.children[0] as HASTElement;\n      const blockGroup =\n        blockContainer.children.length === 2\n          ? (blockContainer.children[1] as HASTElement)\n          : null;\n\n      const isListItemBlock = listItemBlockTypes.has(\n        blockContent.properties![\"dataContentType\"] as string\n      );\n\n      const listItemBlockType = isListItemBlock\n        ? options.orderedListItemBlockTypes.has(\n            blockContent.properties![\"dataContentType\"] as string\n          )\n          ? \"ol\"\n          : \"ul\"\n        : null;\n\n      // Plugin runs recursively to process nested blocks.\n      if (blockGroup !== null) {\n        simplifyBlocksHelper(blockGroup);\n      }\n\n      // Checks that there is an active list, but the block can't be added to it as it's of a different type.\n      if (activeList && activeList.tagName !== listItemBlockType) {\n        // Blocks that were copied into the list are removed and the list is inserted in their place.\n        tree.children.splice(\n          i - activeList.children.length,\n          activeList.children.length,\n          activeList\n        );\n\n        // Updates the current index and number of child elements.\n        const numElementsRemoved = activeList.children.length - 1;\n        i -= numElementsRemoved;\n        numChildElements -= numElementsRemoved;\n\n        activeList = undefined;\n      }\n\n      // Checks if the block represents a list item.\n      if (isListItemBlock) {\n        // Checks if a list isn't already active. We don't have to check if the block and the list are of the same\n        // type as this was already done earlier.\n        if (!activeList) {\n          // Creates a new list element to represent an active list.\n          activeList = fromDom(\n            document.createElement(listItemBlockType!)\n          ) as HASTElement;\n        }\n\n        // Creates a new list item element to represent the block.\n        const listItemElement = fromDom(\n          document.createElement(\"li\")\n        ) as HASTElement;\n\n        // Adds only the content inside the block to the active list.\n        listItemElement.children.push(blockContent.children[0]);\n        // Nested blocks have already been processed in the recursive function call, so the resulting elements are\n        // also added to the active list.\n        if (blockGroup !== null) {\n          listItemElement.children.push(...blockGroup.children);\n        }\n\n        // Adds the list item representing the block to the active list.\n        activeList.children.push(listItemElement);\n      } else if (blockGroup !== null) {\n        // Lifts all children out of the current block, as only list items should allow nesting.\n        tree.children.splice(i + 1, 0, ...blockGroup.children);\n        // Replaces the block with only the content inside it.\n        tree.children[i] = blockContent.children[0];\n\n        // Updates the current index and number of child elements.\n        const numElementsAdded = blockGroup.children.length;\n        i += numElementsAdded;\n        numChildElements += numElementsAdded;\n      } else {\n        // Replaces the block with only the content inside it.\n        tree.children[i] = blockContent.children[0];\n      }\n    }\n\n    // Since the active list is only inserted after encountering a block which can't be added to it, there are cases\n    // where it remains un-inserted after processing all blocks, which are handled here.\n    if (activeList) {\n      tree.children.splice(\n        numChildElements - activeList.children.length,\n        activeList.children.length,\n        activeList\n      );\n    }\n  };\n\n  return simplifyBlocksHelper;\n}\n","import { DOMParser, DOMSerializer, Schema } from \"prosemirror-model\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeRemark from \"rehype-remark\";\nimport rehypeStringify from \"rehype-stringify\";\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype from \"remark-rehype\";\nimport remarkStringify from \"remark-stringify\";\nimport { unified } from \"unified\";\nimport { Block, BlockSchema } from \"../../extensions/Blocks/api/blockTypes\";\n\nimport { blockToNode, nodeToBlock } from \"../nodeConversions/nodeConversions\";\nimport { removeUnderlines } from \"./removeUnderlinesRehypePlugin\";\nimport { simplifyBlocks } from \"./simplifyBlocksRehypePlugin\";\n\nexport async function blocksToHTML<BSchema extends BlockSchema>(\n  blocks: Block<BSchema>[],\n  schema: Schema\n): Promise<string> {\n  const htmlParentElement = document.createElement(\"div\");\n  const serializer = DOMSerializer.fromSchema(schema);\n\n  for (const block of blocks) {\n    const node = blockToNode(block, schema);\n    const htmlNode = serializer.serializeNode(node);\n    htmlParentElement.appendChild(htmlNode);\n  }\n\n  const htmlString = await unified()\n    .use(rehypeParse, { fragment: true })\n    .use(simplifyBlocks, {\n      orderedListItemBlockTypes: new Set<string>([\"numberedListItem\"]),\n      unorderedListItemBlockTypes: new Set<string>([\"bulletListItem\"]),\n    })\n    .use(rehypeStringify)\n    .process(htmlParentElement.innerHTML);\n\n  return htmlString.value as string;\n}\n\nexport async function HTMLToBlocks<BSchema extends BlockSchema>(\n  html: string,\n  blockSchema: BSchema,\n  schema: Schema\n): Promise<Block<BSchema>[]> {\n  const htmlNode = document.createElement(\"div\");\n  htmlNode.innerHTML = html.trim();\n\n  const parser = DOMParser.fromSchema(schema);\n  const parentNode = parser.parse(htmlNode);\n\n  const blocks: Block<BSchema>[] = [];\n\n  for (let i = 0; i < parentNode.firstChild!.childCount; i++) {\n    blocks.push(nodeToBlock(parentNode.firstChild!.child(i), blockSchema));\n  }\n\n  return blocks;\n}\n\nexport async function blocksToMarkdown<BSchema extends BlockSchema>(\n  blocks: Block<BSchema>[],\n  schema: Schema\n): Promise<string> {\n  const markdownString = await unified()\n    .use(rehypeParse, { fragment: true })\n    .use(removeUnderlines)\n    .use(rehypeRemark)\n    .use(remarkGfm)\n    .use(remarkStringify)\n    .process(await blocksToHTML(blocks, schema));\n\n  return markdownString.value as string;\n}\n\nexport async function markdownToBlocks<BSchema extends BlockSchema>(\n  markdown: string,\n  blockSchema: BSchema,\n  schema: Schema\n): Promise<Block<BSchema>[]> {\n  const htmlString = await unified()\n    .use(remarkParse)\n    .use(remarkGfm)\n    .use(remarkRehype)\n    .use(rehypeStringify)\n    .process(markdown);\n\n  return HTMLToBlocks(htmlString.value as string, blockSchema, schema);\n}\n","import { Extension } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    blockBackgroundColor: {\n      setBlockBackgroundColor: (\n        posInBlock: number,\n        color: string\n      ) => ReturnType;\n    };\n  }\n}\n\nexport const BackgroundColorExtension = Extension.create({\n  name: \"blockBackgroundColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          backgroundColor: {\n            default: \"default\",\n            parseHTML: (element) =>\n              element.hasAttribute(\"data-background-color\")\n                ? element.getAttribute(\"data-background-color\")\n                : \"default\",\n            renderHTML: (attributes) =>\n              attributes.backgroundColor !== \"default\" && {\n                \"data-background-color\": attributes.backgroundColor,\n              },\n          },\n        },\n      },\n    ];\n  },\n\n  addCommands() {\n    return {\n      setBlockBackgroundColor:\n        (posInBlock, color) =>\n        ({ state, view }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          state.tr.setNodeAttribute(\n            blockInfo.startPos - 1,\n            \"backgroundColor\",\n            color\n          );\n\n          view.focus();\n\n          return true;\n        },\n    };\n  },\n});\n","import { Mark } from \"@tiptap/core\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    backgroundColor: {\n      setBackgroundColor: (color: string) => ReturnType;\n    };\n  }\n}\n\nexport const BackgroundColorMark = Mark.create({\n  name: \"backgroundColor\",\n\n  addAttributes() {\n    return {\n      color: {\n        default: undefined,\n        parseHTML: (element) => element.getAttribute(\"data-background-color\"),\n        renderHTML: (attributes) => ({\n          \"data-background-color\": attributes.color,\n        }),\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.hasAttribute(\"data-background-color\")) {\n            return { color: element.getAttribute(\"data-background-color\") };\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"span\", HTMLAttributes, 0];\n  },\n\n  addCommands() {\n    return {\n      setBackgroundColor:\n        (color) =>\n        ({ commands }) => {\n          if (color !== \"default\") {\n            return commands.setMark(this.name, { color: color });\n          }\n\n          return commands.unsetMark(this.name);\n        },\n    };\n  },\n});\n","import { findChildren } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\nconst PLUGIN_KEY = new PluginKey(`previous-blocks`);\n\nconst nodeAttributes: Record<string, string> = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\",\n};\n\n/**\n * This plugin tracks transformation of Block node attributes, so we can support CSS transitions.\n *\n * Problem it solves: ProseMirror recreates the DOM when transactions happen. So when a transaction changes a Node attribute,\n * it results in a completely new DOM element. This means CSS transitions don't work.\n *\n * Solution: When attributes change on a node, this plugin sets a data-* attribute with the \"previous\" value. This way we can still use CSS transitions. (See block.module.css)\n */\nexport const PreviousBlockTypePlugin = () => {\n  let timeout: any;\n  return new Plugin({\n    key: PLUGIN_KEY,\n    view(_editorView) {\n      return {\n        update: async (view, _prevState) => {\n          if (this.key?.getState(view.state).updatedBlocks.size > 0) {\n            // use setTimeout 0 to clear the decorations so that at least\n            // for one DOM-render the decorations have been applied\n            timeout = setTimeout(() => {\n              view.dispatch(\n                view.state.tr.setMeta(PLUGIN_KEY, { clearUpdate: true })\n              );\n            }, 0);\n          }\n        },\n        destroy: () => {\n          if (timeout) {\n            clearTimeout(timeout);\n          }\n        },\n      };\n    },\n    state: {\n      init() {\n        return {\n          // Block attributes, by block ID, from just before the previous transaction.\n          prevTransactionOldBlockAttrs: {} as any,\n          // Block attributes, by block ID, from just before the current transaction.\n          currentTransactionOldBlockAttrs: {} as any,\n          // Set of IDs of blocks whose attributes changed from the current transaction.\n          updatedBlocks: new Set<string>(),\n        };\n      },\n\n      apply(transaction, prev, oldState, newState) {\n        prev.currentTransactionOldBlockAttrs = {};\n        prev.updatedBlocks.clear();\n\n        if (!transaction.docChanged || oldState.doc.eq(newState.doc)) {\n          return prev;\n        }\n\n        // TODO: Instead of iterating through the entire document, only check nodes affected by the transactions. Will\n        //  also probably require checking nodes affected by the previous transaction too.\n        // We didn't get this to work yet:\n        // const transform = combineTransactionSteps(oldState.doc, [transaction]);\n        // // const { mapping } = transform;\n        // const changes = getChangedRanges(transform);\n        //\n        // changes.forEach(({ oldRange, newRange }) => {\n        // const oldNodes = findChildrenInRange(\n        //   oldState.doc,\n        //   oldRange,\n        //   (node) => node.attrs.id\n        // );\n        //\n        // const newNodes = findChildrenInRange(\n        //   newState.doc,\n        //   newRange,\n        //   (node) => node.attrs.id\n        // );\n\n        const currentTransactionOriginalOldBlockAttrs = {} as any;\n\n        const oldNodes = findChildren(oldState.doc, (node) => node.attrs.id);\n        const oldNodesById = new Map(\n          oldNodes.map((node) => [node.node.attrs.id, node])\n        );\n        const newNodes = findChildren(newState.doc, (node) => node.attrs.id);\n\n        // Traverses all block containers in the new editor state.\n        for (let node of newNodes) {\n          const oldNode = oldNodesById.get(node.node.attrs.id);\n\n          const oldContentNode = oldNode?.node.firstChild;\n          const newContentNode = node.node.firstChild;\n\n          if (oldNode && oldContentNode && newContentNode) {\n            const newAttrs = {\n              index: newContentNode.attrs.index,\n              level: newContentNode.attrs.level,\n              type: newContentNode.type.name,\n              depth: newState.doc.resolve(node.pos).depth,\n            };\n\n            let oldAttrs = {\n              index: oldContentNode.attrs.index,\n              level: oldContentNode.attrs.level,\n              type: oldContentNode.type.name,\n              depth: oldState.doc.resolve(oldNode.pos).depth,\n            };\n\n            currentTransactionOriginalOldBlockAttrs[node.node.attrs.id] =\n              oldAttrs;\n\n            // Whenever a transaction is appended by the OrderedListItemIndexPlugin, it's given the metadata:\n            // { \"orderedListIndexing\": true }\n            // These appended transactions happen immediately after any transaction which causes ordered list item\n            // indices to require updating, including those which trigger animations. Therefore, these animations are\n            // immediately overridden when the PreviousBlockTypePlugin processes the appended transaction, despite only\n            // the listItemIndex attribute changing. To solve this, oldAttrs must be edited for transactions with the\n            // \"orderedListIndexing\" metadata, so the correct animation can be re-triggered.\n            if (transaction.getMeta(\"numberedListIndexing\")) {\n              // If the block existed before the transaction, gets the attributes from before the previous transaction\n              // (i.e. the transaction that caused list item indices to need updating).\n              if (node.node.attrs.id in prev.prevTransactionOldBlockAttrs) {\n                oldAttrs =\n                  prev.prevTransactionOldBlockAttrs[node.node.attrs.id];\n              }\n\n              // Stops list item indices themselves being animated (looks smoother), unless the block's content type is\n              // changing from a numbered list item to something else.\n              if (newAttrs.type === \"numberedListItem\") {\n                oldAttrs.index = newAttrs.index;\n              }\n            }\n\n            prev.currentTransactionOldBlockAttrs[node.node.attrs.id] = oldAttrs;\n\n            // TODO: faster deep equal?\n            if (JSON.stringify(oldAttrs) !== JSON.stringify(newAttrs)) {\n              (oldAttrs as any)[\"depth-change\"] =\n                oldAttrs.depth - newAttrs.depth;\n\n              // for debugging:\n              // console.log(\n              //   \"id:\",\n              //   node.node.attrs.id,\n              //   \"previousBlockTypePlugin changes detected, oldAttrs\",\n              //   oldAttrs,\n              //   \"new\",\n              //   newAttrs\n              // );\n\n              prev.updatedBlocks.add(node.node.attrs.id);\n            }\n          }\n        }\n\n        prev.prevTransactionOldBlockAttrs =\n          currentTransactionOriginalOldBlockAttrs;\n\n        return prev;\n      },\n    },\n    props: {\n      decorations(state) {\n        const pluginState = (this as Plugin).getState(state);\n        if (pluginState.updatedBlocks.size === 0) {\n          return undefined;\n        }\n\n        const decorations: Decoration[] = [];\n\n        state.doc.descendants((node, pos) => {\n          if (!node.attrs.id) {\n            return;\n          }\n\n          if (!pluginState.updatedBlocks.has(node.attrs.id)) {\n            return;\n          }\n\n          const prevAttrs =\n            pluginState.currentTransactionOldBlockAttrs[node.attrs.id];\n          const decorationAttrs: any = {};\n\n          for (let [nodeAttr, val] of Object.entries(prevAttrs)) {\n            decorationAttrs[\"data-prev-\" + nodeAttributes[nodeAttr]] =\n              val || \"none\";\n          }\n\n          // for debugging:\n          // console.log(\n          //   \"previousBlockTypePlugin committing decorations\",\n          //   decorationAttrs\n          // );\n\n          const decoration = Decoration.node(pos, pos + node.nodeSize, {\n            ...decorationAttrs,\n          });\n\n          decorations.push(decoration);\n        });\n\n        return DecorationSet.create(state.doc, decorations);\n      },\n    },\n  });\n};\n","// Object containing all possible block attributes.\nconst BlockAttributes: Record<string, string> = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\",\n};\n\nexport default BlockAttributes;\n","import { mergeAttributes, Node } from \"@tiptap/core\";\nimport { Fragment, Node as PMNode, Slice } from \"prosemirror-model\";\nimport { TextSelection } from \"prosemirror-state\";\nimport {\n  blockToNode,\n  inlineContentToNodes,\n} from \"../../../api/nodeConversions/nodeConversions\";\n\nimport { getBlockInfoFromPos } from \"../helpers/getBlockInfoFromPos\";\nimport { PreviousBlockTypePlugin } from \"../PreviousBlockTypePlugin\";\nimport styles from \"./Block.module.css\";\nimport BlockAttributes from \"./BlockAttributes\";\nimport { BlockSchema, PartialBlock } from \"../api/blockTypes\";\n\n// TODO\nexport interface IBlock {\n  HTMLAttributes: Record<string, any>;\n}\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    block: {\n      BNCreateBlock: (pos: number) => ReturnType;\n      BNDeleteBlock: (posInBlock: number) => ReturnType;\n      BNMergeBlocks: (posBetweenBlocks: number) => ReturnType;\n      BNSplitBlock: (posInBlock: number, keepType: boolean) => ReturnType;\n      BNUpdateBlock: <BSchema extends BlockSchema>(\n        posInBlock: number,\n        block: PartialBlock<BSchema>\n      ) => ReturnType;\n      BNCreateOrUpdateBlock: <BSchema extends BlockSchema>(\n        posInBlock: number,\n        block: PartialBlock<BSchema>\n      ) => ReturnType;\n    };\n  }\n}\n\n/**\n * The main \"Block node\" documents consist of\n */\nexport const BlockContainer = Node.create<IBlock>({\n  name: \"blockContainer\",\n  group: \"blockContainer\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: true,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          const attrs: Record<string, string> = {};\n          for (let [nodeAttr, HTMLAttr] of Object.entries(BlockAttributes)) {\n            if (element.getAttribute(HTMLAttr)) {\n              attrs[nodeAttr] = element.getAttribute(HTMLAttr)!;\n            }\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockContainer\") {\n            return attrs;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(HTMLAttributes, {\n        class: styles.blockOuter,\n        \"data-node-type\": \"block-outer\",\n      }),\n      [\n        \"div\",\n        mergeAttributes(HTMLAttributes, {\n          // TODO: maybe remove html attributes from inner block\n          class: styles.block,\n          \"data-node-type\": this.name,\n        }),\n        0,\n      ],\n    ];\n  },\n\n  addCommands() {\n    return {\n      // Creates a new text block at a given position.\n      BNCreateBlock:\n        (pos) =>\n        ({ state, dispatch }) => {\n          const newBlock =\n            state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n          if (dispatch) {\n            state.tr.insert(pos, newBlock);\n          }\n\n          return true;\n        },\n      // Deletes a block at a given position.\n      BNDeleteBlock:\n        (posInBlock) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { startPos, endPos } = blockInfo;\n\n          if (dispatch) {\n            state.tr.deleteRange(startPos, endPos);\n          }\n\n          return true;\n        },\n      // Updates a block at a given position.\n      BNUpdateBlock:\n        (posInBlock, block) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { startPos, endPos, node, contentNode } = blockInfo;\n\n          if (dispatch) {\n            // Adds blockGroup node with child blocks if necessary.\n            if (block.children !== undefined) {\n              const childNodes = [];\n\n              // Creates ProseMirror nodes for each child block, including their descendants.\n              for (const child of block.children) {\n                childNodes.push(blockToNode(child, state.schema));\n              }\n\n              // Checks if a blockGroup node already exists.\n              if (node.childCount === 2) {\n                // Replaces all child nodes in the existing blockGroup with the ones created earlier.\n                state.tr.replace(\n                  startPos + contentNode.nodeSize + 1,\n                  endPos - 1,\n                  new Slice(Fragment.from(childNodes), 0, 0)\n                );\n              } else {\n                // Inserts a new blockGroup containing the child nodes created earlier.\n                state.tr.insert(\n                  startPos + contentNode.nodeSize,\n                  state.schema.nodes[\"blockGroup\"].create({}, childNodes)\n                );\n              }\n            }\n\n            // Replaces the blockContent node's content if necessary.\n            if (block.content !== undefined) {\n              let content: PMNode[] = [];\n\n              // Checks if the provided content is a string or InlineContent[] type.\n              if (typeof block.content === \"string\") {\n                // Adds a single text node with no marks to the content.\n                content.push(state.schema.text(block.content));\n              } else {\n                // Adds a text node with the provided styles converted into marks to the content, for each InlineContent\n                // object.\n                content = inlineContentToNodes(block.content, state.schema);\n              }\n\n              // Replaces the contents of the blockContent node with the previously created text node(s).\n              state.tr.replace(\n                startPos + 1,\n                startPos + contentNode.nodeSize - 1,\n                new Slice(Fragment.from(content), 0, 0)\n              );\n            }\n\n            // Changes the blockContent node type and adds the provided props as attributes. Also preserves all existing\n            // attributes that are compatible with the new type.\n            state.tr.setNodeMarkup(\n              startPos,\n              block.type === undefined\n                ? undefined\n                : state.schema.nodes[block.type],\n              {\n                ...contentNode.attrs,\n                ...block.props,\n              }\n            );\n\n            // Adds all provided props as attributes to the parent blockContainer node too, and also preserves existing\n            // attributes.\n            state.tr.setNodeMarkup(startPos - 1, undefined, {\n              ...node.attrs,\n              ...block.props,\n            });\n          }\n\n          return true;\n        },\n      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of\n      // the merged block are moved out of it first, rather than also being merged.\n      //\n      // In the example below, the position passed into the function is between Block1 and Block2.\n      //\n      // Block1\n      //    Block2\n      // Block3\n      //    Block4\n      //        Block5\n      //\n      // Becomes:\n      //\n      // Block1\n      //    Block2Block3\n      // Block4\n      //     Block5\n      BNMergeBlocks:\n        (posBetweenBlocks) =>\n        ({ state, dispatch }) => {\n          const nextNodeIsBlock =\n            state.doc.resolve(posBetweenBlocks + 1).node().type.name ===\n            \"blockContainer\";\n          const prevNodeIsBlock =\n            state.doc.resolve(posBetweenBlocks - 1).node().type.name ===\n            \"blockContainer\";\n\n          if (!nextNodeIsBlock || !prevNodeIsBlock) {\n            return false;\n          }\n\n          const nextBlockInfo = getBlockInfoFromPos(\n            state.doc,\n            posBetweenBlocks + 1\n          );\n\n          const { node, contentNode, startPos, endPos, depth } = nextBlockInfo!;\n\n          // Removes a level of nesting all children of the next block by 1 level, if it contains both content and block\n          // group nodes.\n          if (node.childCount === 2) {\n            const childBlocksStart = state.doc.resolve(\n              startPos + contentNode.nodeSize + 1\n            );\n            const childBlocksEnd = state.doc.resolve(endPos - 1);\n            const childBlocksRange =\n              childBlocksStart.blockRange(childBlocksEnd);\n\n            // Moves the block group node inside the block into the block group node that the current block is in.\n            if (dispatch) {\n              state.tr.lift(childBlocksRange!, depth - 1);\n            }\n          }\n\n          let prevBlockEndPos = posBetweenBlocks - 1;\n          let prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);\n\n          // Finds the nearest previous block, regardless of nesting level.\n          while (prevBlockInfo!.numChildBlocks > 0) {\n            prevBlockEndPos--;\n            prevBlockInfo = getBlockInfoFromPos(state.doc, prevBlockEndPos);\n            if (prevBlockInfo === undefined) {\n              return false;\n            }\n          }\n\n          // Deletes next block and adds its text content to the nearest previous block.\n\n          if (dispatch) {\n            dispatch(\n              state.tr\n                .deleteRange(startPos, startPos + contentNode.nodeSize)\n                .replace(\n                  prevBlockEndPos - 1,\n                  startPos,\n                  new Slice(contentNode.content, 0, 0)\n                )\n                .scrollIntoView()\n            );\n\n            state.tr.setSelection(\n              new TextSelection(state.doc.resolve(prevBlockEndPos - 1))\n            );\n          }\n\n          return true;\n        },\n      // Splits a block at a given position. Content after the position is moved to a new block below, at the same\n      // nesting level.\n      BNSplitBlock:\n        (posInBlock, keepType) =>\n        ({ state, dispatch }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          const { contentNode, contentType, startPos, endPos, depth } =\n            blockInfo;\n\n          const originalBlockContent = state.doc.cut(startPos + 1, posInBlock);\n          const newBlockContent = state.doc.cut(posInBlock, endPos - 1);\n\n          const newBlock =\n            state.schema.nodes[\"blockContainer\"].createAndFill()!;\n\n          const newBlockInsertionPos = endPos + 1;\n          const newBlockContentPos = newBlockInsertionPos + 2;\n\n          if (dispatch) {\n            // Creates a new block. Since the schema requires it to have a content node, a paragraph node is created\n            // automatically, spanning newBlockContentPos to newBlockContentPos + 1.\n            state.tr.insert(newBlockInsertionPos, newBlock);\n\n            // Replaces the content of the newly created block's content node. Doesn't replace the whole content node so\n            // its type doesn't change.\n            state.tr.replace(\n              newBlockContentPos,\n              newBlockContentPos + 1,\n              newBlockContent.content.size > 0\n                ? new Slice(\n                    Fragment.from(newBlockContent),\n                    depth + 2,\n                    depth + 2\n                  )\n                : undefined\n            );\n\n            // Changes the type of the content node. The range doesn't matter as long as both from and to positions are\n            // within the content node.\n            if (keepType) {\n              state.tr.setBlockType(\n                newBlockContentPos,\n                newBlockContentPos,\n                state.schema.node(contentType).type,\n                contentNode.attrs\n              );\n            }\n\n            // Sets the selection to the start of the new block's content node.\n            state.tr.setSelection(\n              new TextSelection(state.doc.resolve(newBlockContentPos))\n            );\n\n            // Replaces the content of the original block's content node. Doesn't replace the whole content node so its\n            // type doesn't change.\n            state.tr.replace(\n              startPos + 1,\n              endPos - 1,\n              originalBlockContent.content.size > 0\n                ? new Slice(\n                    Fragment.from(originalBlockContent),\n                    depth + 2,\n                    depth + 2\n                  )\n                : undefined\n            );\n          }\n\n          return true;\n        },\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [PreviousBlockTypePlugin()];\n  },\n\n  addKeyboardShortcuts() {\n    // handleBackspace is partially adapted from https://github.com/ueberdosis/tiptap/blob/ed56337470efb4fd277128ab7ef792b37cfae992/packages/core/src/extensions/keymap.ts\n    const handleBackspace = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Deletes the selection if it's not empty.\n        () => commands.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => commands.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { contentType } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const isParagraph = contentType.name === \"paragraph\";\n\n            if (selectionAtBlockStart && !isParagraph) {\n              return commands.BNUpdateBlock(state.selection.from, {\n                type: \"paragraph\",\n                props: {},\n              });\n            }\n\n            return false;\n          }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n\n            if (selectionAtBlockStart) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection\n        // is at the start of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { depth, startPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockAtDocStart = startPos === 2;\n\n            const posBetweenBlocks = startPos - 1;\n\n            if (\n              !blockAtDocStart &&\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              depth === 2\n            ) {\n              return commands.BNMergeBlocks(posBetweenBlocks);\n            }\n\n            return false;\n          }),\n      ]);\n\n    const handleEnter = () =>\n      this.editor.commands.first(({ commands }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () =>\n          commands.command(({ state }) => {\n            const { node, depth } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = node.textContent.length === 0;\n            const blockIndented = depth > 2;\n\n            if (\n              selectionAtBlockStart &&\n              selectionEmpty &&\n              blockEmpty &&\n              blockIndented\n            ) {\n              return commands.liftListItem(\"blockContainer\");\n            }\n\n            return false;\n          }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () =>\n          commands.command(({ state, chain }) => {\n            const { node, endPos } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const selectionAtBlockStart =\n              state.selection.$anchor.parentOffset === 0;\n            const selectionEmpty =\n              state.selection.anchor === state.selection.head;\n            const blockEmpty = node.textContent.length === 0;\n\n            if (selectionAtBlockStart && selectionEmpty && blockEmpty) {\n              const newBlockInsertionPos = endPos + 1;\n              const newBlockContentPos = newBlockInsertionPos + 2;\n\n              chain()\n                .BNCreateBlock(newBlockInsertionPos)\n                .setTextSelection(newBlockContentPos)\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () =>\n          commands.command(({ state, chain }) => {\n            const { node } = getBlockInfoFromPos(\n              state.doc,\n              state.selection.from\n            )!;\n\n            const blockEmpty = node.textContent.length === 0;\n\n            if (!blockEmpty) {\n              chain()\n                .deleteSelection()\n                .BNSplitBlock(state.selection.from, false)\n                .run();\n\n              return true;\n            }\n\n            return false;\n          }),\n      ]);\n\n    return {\n      Backspace: handleBackspace,\n      Enter: handleEnter,\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => {\n        this.editor.commands.sinkListItem(\"blockContainer\");\n        return true;\n      },\n      \"Shift-Tab\": () => {\n        this.editor.commands.liftListItem(\"blockContainer\");\n        return true;\n      },\n      \"Mod-Alt-0\": () =>\n        this.editor.commands.BNCreateBlock(\n          this.editor.state.selection.anchor + 2\n        ),\n      \"Mod-Alt-1\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"heading\",\n          props: {\n            level: \"1\",\n          },\n        }),\n      \"Mod-Alt-2\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"heading\",\n          props: {\n            level: \"2\",\n          },\n        }),\n      \"Mod-Alt-3\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"heading\",\n          props: {\n            level: \"3\",\n          },\n        }),\n      \"Mod-Shift-7\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"bulletListItem\",\n          props: {},\n        }),\n      \"Mod-Shift-8\": () =>\n        this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n          type: \"numberedListItem\",\n          props: {},\n        }),\n    };\n  },\n});\n","import { mergeAttributes, Node } from \"@tiptap/core\";\nimport styles from \"./Block.module.css\";\n\nexport const BlockGroup = Node.create({\n  name: \"blockGroup\",\n  group: \"blockGroup\",\n  content: \"blockContainer+\",\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.getAttribute(\"data-node-type\") === \"blockGroup\") {\n            // Null means the element matches, but we don't want to add any attributes to the node.\n            return null;\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        class: styles.blockGroup,\n        \"data-node-type\": \"blockGroup\",\n      }),\n      0,\n    ];\n  },\n});\n","import { Node } from \"@tiptap/core\";\nimport { BlockContainer } from \"./nodes/BlockContainer\";\nimport { BlockGroup } from \"./nodes/BlockGroup\";\n\nexport const blocks: any[] = [\n  BlockContainer,\n  BlockGroup,\n  Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"blockGroup\",\n  }),\n];\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\nimport { DOMSerializer, Schema } from \"prosemirror-model\";\n\nconst customBlockSerializer = (schema: Schema) => {\n  const defaultSerializer = DOMSerializer.fromSchema(schema);\n\n  return new DOMSerializer(\n    {\n      ...defaultSerializer.nodes,\n      // TODO: If a serializer is defined in the config for a custom block, it\n      //  should be added here. We still need to figure out how the serializer\n      //  should be defined in the custom blocks API though, and implement that,\n      //  before we can do this.\n    },\n    defaultSerializer.marks\n  );\n};\nexport const CustomBlockSerializerExtension = Extension.create({\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        props: {\n          clipboardSerializer: customBlockSerializer(this.editor.schema),\n        },\n      }),\n    ];\n  },\n});","import { findParentNode } from \"@tiptap/core\";\n\nexport const findBlock = findParentNode(\n  (node) => node.type.name === \"blockContainer\"\n);\n","import { Editor, Range } from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet, EditorView } from \"prosemirror-view\";\nimport { findBlock } from \"../../../extensions/Blocks/helpers/findBlock\";\nimport {\n  SuggestionsMenu,\n  SuggestionsMenuDynamicParams,\n  SuggestionsMenuFactory,\n  SuggestionsMenuStaticParams,\n} from \"./SuggestionsMenuFactoryTypes\";\nimport { SuggestionItem } from \"./SuggestionItem\";\nimport { BlockNoteEditor } from \"../../../BlockNoteEditor\";\nimport { BlockSchema } from \"../../../extensions/Blocks/api/blockTypes\";\n\nexport type SuggestionPluginOptions<\n  T extends SuggestionItem,\n  BSchema extends BlockSchema\n> = {\n  /**\n   * The name of the plugin.\n   *\n   * Used for ensuring that the plugin key is unique when more than one instance of the SuggestionPlugin is used.\n   */\n  pluginKey: PluginKey;\n\n  /**\n   * The BlockNote editor.\n   */\n  editor: BlockNoteEditor<BSchema>;\n\n  /**\n   * The character that should trigger the suggestion menu to pop up (e.g. a '/' for commands), when typed by the user.\n   */\n  defaultTriggerCharacter: string;\n\n  suggestionsMenuFactory: SuggestionsMenuFactory<T>;\n\n  /**\n   * The callback that gets executed when an item is selected by the user.\n   *\n   * **NOTE:** The command text is not removed automatically from the editor by this plugin,\n   * this should be done manually. The `editor` and `range` properties passed\n   * to the callback function might come in handy when doing this.\n   */\n  onSelectItem?: (props: { item: T; editor: BlockNoteEditor<BSchema> }) => void;\n\n  /**\n   * A function that should supply the plugin with items to suggest, based on a certain query string.\n   */\n  items?: (query: string) => T[];\n\n  allow?: (props: { editor: Editor; range: Range }) => boolean;\n};\n\ntype SuggestionPluginState<T extends SuggestionItem> = {\n  // True when the menu is shown, false when hidden.\n  active: boolean;\n  // The character that triggered the menu being shown. Allowing the trigger to be different to the default\n  // trigger allows other extensions to open it programmatically.\n  triggerCharacter: string | undefined;\n  // The editor position just after the trigger character, i.e. where the user query begins. Used to figure out\n  // which menu items to show and can also be used to delete the trigger character.\n  queryStartPos: number | undefined;\n  // The items that should be shown in the menu.\n  items: T[];\n  // The index of the item in the menu that's currently hovered using the keyboard.\n  keyboardHoveredItemIndex: number | undefined;\n  // The number of characters typed after the last query that matched with at least 1 item. Used to close the\n  // menu if the user keeps entering queries that don't return any results.\n  notFoundCount: number | undefined;\n  decorationId: string | undefined;\n};\n\nfunction getDefaultPluginState<\n  T extends SuggestionItem\n>(): SuggestionPluginState<T> {\n  return {\n    active: false,\n    triggerCharacter: undefined,\n    queryStartPos: undefined,\n    items: [] as T[],\n    keyboardHoveredItemIndex: undefined,\n    notFoundCount: 0,\n    decorationId: undefined,\n  };\n}\n\ntype SuggestionPluginViewOptions<\n  T extends SuggestionItem,\n  BSchema extends BlockSchema\n> = {\n  editor: BlockNoteEditor<BSchema>;\n  pluginKey: PluginKey;\n  onSelectItem: (props: { item: T; editor: BlockNoteEditor<BSchema> }) => void;\n  suggestionsMenuFactory: SuggestionsMenuFactory<T>;\n};\n\nclass SuggestionPluginView<\n  T extends SuggestionItem,\n  BSchema extends BlockSchema\n> {\n  editor: BlockNoteEditor<BSchema>;\n  pluginKey: PluginKey;\n\n  suggestionsMenu: SuggestionsMenu<T>;\n\n  pluginState: SuggestionPluginState<T>;\n  itemCallback: (item: T) => void;\n\n  private lastPosition: DOMRect | undefined;\n\n  constructor({\n    editor,\n    pluginKey,\n    onSelectItem: selectItemCallback = () => {},\n    suggestionsMenuFactory,\n  }: SuggestionPluginViewOptions<T, BSchema>) {\n    this.editor = editor;\n    this.pluginKey = pluginKey;\n\n    this.pluginState = getDefaultPluginState<T>();\n\n    this.itemCallback = (item: T) => {\n      editor._tiptapEditor\n        .chain()\n        .focus()\n        .deleteRange({\n          from:\n            this.pluginState.queryStartPos! -\n            this.pluginState.triggerCharacter!.length,\n          to: editor._tiptapEditor.state.selection.from,\n        })\n        .run();\n\n      selectItemCallback({\n        item: item,\n        editor: editor,\n      });\n    };\n\n    this.suggestionsMenu = suggestionsMenuFactory(this.getStaticParams());\n  }\n\n  update(view: EditorView, prevState: EditorState) {\n    const prev = this.pluginKey.getState(prevState);\n    const next = this.pluginKey.getState(view.state);\n\n    // See how the state changed\n    const started = !prev.active && next.active;\n    const stopped = prev.active && !next.active;\n    // TODO: Currently also true for cases in which an update isn't needed so selected list item index updates still\n    //  cause the view to update. May need to be more strict.\n    const changed = prev.active && next.active;\n\n    // Cancel when suggestion isn't active\n    if (!started && !changed && !stopped) {\n      return;\n    }\n\n    this.pluginState = stopped ? prev : next;\n\n    if (stopped || !this.editor.isEditable) {\n      this.suggestionsMenu.hide();\n\n      // Listener stops focus moving to the menu on click.\n      this.suggestionsMenu.element!.removeEventListener(\"mousedown\", (event) =>\n        event.preventDefault()\n      );\n    }\n\n    if (changed) {\n      this.suggestionsMenu.render(this.getDynamicParams(), false);\n    }\n\n    if (started && this.editor.isEditable) {\n      this.suggestionsMenu.render(this.getDynamicParams(), true);\n\n      // Listener stops focus moving to the menu on click.\n      this.suggestionsMenu.element!.addEventListener(\"mousedown\", (event) =>\n        event.preventDefault()\n      );\n    }\n  }\n\n  getStaticParams(): SuggestionsMenuStaticParams<T> {\n    return {\n      itemCallback: (item: T) => this.itemCallback(item),\n      getReferenceRect: () => {\n        const decorationNode = document.querySelector(\n          `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n        );\n\n        if (!decorationNode) {\n          if (this.lastPosition === undefined) {\n            throw new Error(\n              \"Attempted to access trigger character reference rect before rendering suggestions menu.\"\n            );\n          }\n\n          return this.lastPosition;\n        }\n\n        const triggerCharacterBoundingBox =\n          decorationNode.getBoundingClientRect();\n        this.lastPosition = triggerCharacterBoundingBox;\n\n        return triggerCharacterBoundingBox;\n      },\n    };\n  }\n\n  getDynamicParams(): SuggestionsMenuDynamicParams<T> {\n    return {\n      items: this.pluginState.items,\n      keyboardHoveredItemIndex: this.pluginState.keyboardHoveredItemIndex!,\n    };\n  }\n}\n\n/**\n * A ProseMirror plugin for suggestions, designed to make '/'-commands possible as well as mentions.\n *\n * This is basically a simplified version of TipTap's [Suggestions](https://github.com/ueberdosis/tiptap/tree/db92a9b313c5993b723c85cd30256f1d4a0b65e1/packages/suggestion) plugin.\n *\n * This version is adapted from the aforementioned version in the following ways:\n * - This version supports generic items instead of only strings (to allow for more advanced filtering for example)\n * - This version hides some unnecessary complexity from the user of the plugin.\n * - This version handles key events differently\n *\n * @param options options for configuring the plugin\n * @returns the prosemirror plugin\n */\nexport function createSuggestionPlugin<\n  T extends SuggestionItem,\n  BSchema extends BlockSchema\n>({\n  pluginKey,\n  editor,\n  defaultTriggerCharacter,\n  suggestionsMenuFactory,\n  onSelectItem: selectItemCallback = () => {},\n  items = () => [],\n}: SuggestionPluginOptions<T, BSchema>) {\n  // Assertions\n  if (defaultTriggerCharacter.length !== 1) {\n    throw new Error(\"'char' should be a single character\");\n  }\n\n  const deactivate = (view: EditorView) => {\n    view.dispatch(view.state.tr.setMeta(pluginKey, { deactivate: true }));\n  };\n\n  // Plugin key is passed in as a parameter, so it can be exported and used in the DraggableBlocksPlugin.\n  return new Plugin({\n    key: pluginKey,\n\n    view: (view: EditorView) =>\n      new SuggestionPluginView<T, BSchema>({\n        editor: editor,\n        pluginKey: pluginKey,\n        onSelectItem: (props: {\n          item: T;\n          editor: BlockNoteEditor<BSchema>;\n        }) => {\n          deactivate(view);\n          selectItemCallback(props);\n        },\n        suggestionsMenuFactory: suggestionsMenuFactory,\n      }),\n\n    state: {\n      // Initialize the plugin's internal state.\n      init(): SuggestionPluginState<T> {\n        return getDefaultPluginState<T>();\n      },\n\n      // Apply changes to the plugin state from an editor transaction.\n      apply(transaction, prev, oldState, newState): SuggestionPluginState<T> {\n        // TODO: More clearly define which transactions should be ignored.\n        if (transaction.getMeta(\"orderedListIndexing\") !== undefined) {\n          return prev;\n        }\n\n        // Checks if the menu should be shown.\n        if (transaction.getMeta(pluginKey)?.activate) {\n          return {\n            active: true,\n            triggerCharacter:\n              transaction.getMeta(pluginKey)?.triggerCharacter || \"\",\n            queryStartPos: newState.selection.from,\n            items: items(\"\"),\n            keyboardHoveredItemIndex: 0,\n            // TODO: Maybe should be 1 if the menu has no possible items? Probably redundant since a menu with no items\n            //  is useless in practice.\n            notFoundCount: 0,\n            decorationId: `id_${Math.floor(Math.random() * 0xffffffff)}`,\n          };\n        }\n\n        // Checks if the menu is hidden, in which case it doesn't need to be hidden or updated.\n        if (!prev.active) {\n          return prev;\n        }\n\n        const next = { ...prev };\n\n        // Updates which menu items to show by checking which items the current query (the text between the trigger\n        // character and caret) matches with.\n        next.items = items(\n          newState.doc.textBetween(prev.queryStartPos!, newState.selection.from)\n        );\n\n        // Updates notFoundCount if the query doesn't match any items.\n        next.notFoundCount = 0;\n        if (next.items.length === 0) {\n          // Checks how many characters were typed or deleted since the last transaction, and updates the notFoundCount\n          // accordingly. Also ensures the notFoundCount does not become negative.\n          next.notFoundCount = Math.max(\n            0,\n            prev.notFoundCount! +\n              (newState.selection.from - oldState.selection.from)\n          );\n        }\n\n        // Hides the menu. This is done after items and notFoundCount are already updated as notFoundCount is needed to\n        // check if the menu should be hidden.\n        if (\n          // Highlighting text should hide the menu.\n          newState.selection.from !== newState.selection.to ||\n          // Transactions with plugin metadata {deactivate: true} should hide the menu.\n          transaction.getMeta(pluginKey)?.deactivate ||\n          // Certain mouse events should hide the menu.\n          // TODO: Change to global mousedown listener.\n          transaction.getMeta(\"focus\") ||\n          transaction.getMeta(\"blur\") ||\n          transaction.getMeta(\"pointer\") ||\n          // Moving the caret before the character which triggered the menu should hide it.\n          (prev.active && newState.selection.from < prev.queryStartPos!) ||\n          // Entering more than 3 characters, after the last query that matched with at least 1 menu item, should hide\n          // the menu.\n          next.notFoundCount > 3\n        ) {\n          return getDefaultPluginState<T>();\n        }\n\n        // Updates keyboardHoveredItemIndex if necessary.\n        if (\n          transaction.getMeta(pluginKey)?.selectedItemIndexChanged !== undefined\n        ) {\n          let newIndex =\n            transaction.getMeta(pluginKey).selectedItemIndexChanged;\n\n          // Allows selection to jump between first and last items.\n          if (newIndex < 0) {\n            newIndex = prev.items.length - 1;\n          } else if (newIndex >= prev.items.length) {\n            newIndex = 0;\n          }\n\n          next.keyboardHoveredItemIndex = newIndex;\n        }\n\n        return next;\n      },\n    },\n\n    props: {\n      handleKeyDown(view, event) {\n        const menuIsActive = (this as Plugin).getState(view.state).active;\n\n        // Shows the menu if the default trigger character was pressed and the menu isn't active.\n        if (event.key === defaultTriggerCharacter && !menuIsActive) {\n          view.dispatch(\n            view.state.tr\n              .insertText(defaultTriggerCharacter)\n              .scrollIntoView()\n              .setMeta(pluginKey, {\n                activate: true,\n                triggerCharacter: defaultTriggerCharacter,\n              })\n          );\n\n          return true;\n        }\n\n        // Doesn't handle other keystrokes if the menu isn't active.\n        if (!menuIsActive) {\n          return false;\n        }\n\n        // Handles keystrokes for navigating the menu.\n        const {\n          triggerCharacter,\n          queryStartPos,\n          items,\n          keyboardHoveredItemIndex,\n        } = pluginKey.getState(view.state);\n\n        // Moves the keyboard selection to the previous item.\n        if (event.key === \"ArrowUp\") {\n          view.dispatch(\n            view.state.tr.setMeta(pluginKey, {\n              selectedItemIndexChanged: keyboardHoveredItemIndex - 1,\n            })\n          );\n          return true;\n        }\n\n        // Moves the keyboard selection to the next item.\n        if (event.key === \"ArrowDown\") {\n          view.dispatch(\n            view.state.tr.setMeta(pluginKey, {\n              selectedItemIndexChanged: keyboardHoveredItemIndex + 1,\n            })\n          );\n          return true;\n        }\n\n        // Selects an item and closes the menu.\n        if (event.key === \"Enter\") {\n          deactivate(view);\n          editor._tiptapEditor\n            .chain()\n            .focus()\n            .deleteRange({\n              from: queryStartPos! - triggerCharacter!.length,\n              to: editor._tiptapEditor.state.selection.from,\n            })\n            .run();\n\n          selectItemCallback({\n            item: items[keyboardHoveredItemIndex],\n            editor: editor,\n          });\n\n          return true;\n        }\n\n        // Closes the menu.\n        if (event.key === \"Escape\") {\n          deactivate(view);\n          return true;\n        }\n\n        return false;\n      },\n\n      // Hides menu in cases where mouse click does not cause an editor state change.\n      handleClick(view) {\n        deactivate(view);\n      },\n\n      // Setup decorator on the currently active suggestion.\n      decorations(state) {\n        const { active, decorationId, queryStartPos, triggerCharacter } = (\n          this as Plugin\n        ).getState(state);\n\n        if (!active) {\n          return null;\n        }\n\n        // If the menu was opened programmatically by another extension, it may not use a trigger character. In this\n        // case, the decoration is set on the whole block instead, as the decoration range would otherwise be empty.\n        if (triggerCharacter === \"\") {\n          const blockNode = findBlock(state.selection);\n          if (blockNode) {\n            return DecorationSet.create(state.doc, [\n              Decoration.node(\n                blockNode.pos,\n                blockNode.pos + blockNode.node.nodeSize,\n                {\n                  nodeName: \"span\",\n                  class: \"suggestion-decorator\",\n                  \"data-decoration-id\": decorationId,\n                }\n              ),\n            ]);\n          }\n        }\n        // Creates an inline decoration around the trigger character.\n        return DecorationSet.create(state.doc, [\n          Decoration.inline(\n            queryStartPos - triggerCharacter.length,\n            queryStartPos,\n            {\n              nodeName: \"span\",\n              class: \"suggestion-decorator\",\n              \"data-decoration-id\": decorationId,\n            }\n          ),\n        ]);\n      },\n    },\n  });\n}\n","import { Extension } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { createSuggestionPlugin } from \"../../shared/plugins/suggestion/SuggestionPlugin\";\nimport { SuggestionsMenuFactory } from \"../../shared/plugins/suggestion/SuggestionsMenuFactoryTypes\";\nimport { BaseSlashMenuItem } from \"./BaseSlashMenuItem\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\nimport { BlockSchema } from \"../Blocks/api/blockTypes\";\n\nexport type SlashMenuOptions<BSchema extends BlockSchema> = {\n  editor: BlockNoteEditor<BSchema> | undefined;\n  commands: BaseSlashMenuItem<BSchema>[] | undefined;\n  slashMenuFactory: SuggestionsMenuFactory<any> | undefined;\n};\n\nexport const SlashMenuPluginKey = new PluginKey(\"suggestions-slash-commands\");\n\nexport const createSlashMenuExtension = <BSchema extends BlockSchema>() =>\n  Extension.create<SlashMenuOptions<BSchema>>({\n    name: \"slash-command\",\n\n    addOptions() {\n      return {\n        editor: undefined,\n        commands: undefined,\n        slashMenuFactory: undefined,\n      };\n    },\n\n    addProseMirrorPlugins() {\n      if (!this.options.slashMenuFactory || !this.options.commands) {\n        throw new Error(\"required args not defined for SlashMenuExtension\");\n      }\n\n      const commands = this.options.commands;\n\n      return [\n        createSuggestionPlugin<BaseSlashMenuItem<BSchema>, BSchema>({\n          pluginKey: SlashMenuPluginKey,\n          editor: this.options.editor!,\n          defaultTriggerCharacter: \"/\",\n          suggestionsMenuFactory: this.options.slashMenuFactory!,\n          items: (query) => {\n            return commands.filter((cmd: BaseSlashMenuItem<BSchema>) =>\n              cmd.match(query)\n            );\n          },\n          onSelectItem: ({ item, editor }) => {\n            item.execute(editor);\n          },\n        }),\n      ];\n    },\n  });\n","import { Selection } from \"prosemirror-state\";\nimport { Fragment, Node, ResolvedPos, Slice } from \"prosemirror-model\";\nimport { Mappable } from \"prosemirror-transform\";\n\n/**\n * This class represents an editor selection which spans multiple nodes/blocks. It's currently only used to allow users\n * to drag multiple blocks at the same time. Expects the selection anchor and head to be between nodes, i.e. just before\n * the first target node and just after the last, and that anchor and head are at the same nesting level.\n *\n * Partially based on ProseMirror's NodeSelection implementation:\n * (https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.ts)\n * MultipleNodeSelection differs from NodeSelection in the following ways:\n * 1. Stores which nodes are included in the selection instead of just a single node.\n * 2. Already expects the selection to start just before the first target node and ends just after the last, while a\n * NodeSelection automatically sets both anchor and head to just before the single target node.\n */\nexport class MultipleNodeSelection extends Selection {\n  nodes: Array<Node>;\n\n  constructor($anchor: ResolvedPos, $head: ResolvedPos) {\n    super($anchor, $head);\n\n    // Parent is at the same nesting level as anchor/head since they are just before/ just after target nodes.\n    const parentNode = $anchor.node();\n\n    this.nodes = [];\n    $anchor.doc.nodesBetween($anchor.pos, $head.pos, (node, _pos, parent) => {\n      if (parent !== null && parent.eq(parentNode)) {\n        this.nodes.push(node);\n        return false;\n      }\n      return;\n    });\n  }\n\n  static create(doc: Node, from: number, to = from): MultipleNodeSelection {\n    return new MultipleNodeSelection(doc.resolve(from), doc.resolve(to));\n  }\n\n  content(): Slice {\n    return new Slice(Fragment.from(this.nodes), 0, 0);\n  }\n\n  eq(selection: Selection): boolean {\n    if (!(selection instanceof MultipleNodeSelection)) {\n      return false;\n    }\n\n    if (this.nodes.length !== selection.nodes.length) {\n      return false;\n    }\n\n    if (this.from !== selection.from || this.to !== selection.to) {\n      return false;\n    }\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      if (!this.nodes[i].eq(selection.nodes[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  map(doc: Node, mapping: Mappable): Selection {\n    let fromResult = mapping.mapResult(this.from);\n    let toResult = mapping.mapResult(this.to);\n\n    if (toResult.deleted) {\n      return Selection.near(doc.resolve(fromResult.pos));\n    }\n\n    if (fromResult.deleted) {\n      return Selection.near(doc.resolve(toResult.pos));\n    }\n\n    return new MultipleNodeSelection(\n      doc.resolve(fromResult.pos),\n      doc.resolve(toResult.pos)\n    );\n  }\n\n  toJSON(): any {\n    return { type: \"node\", anchor: this.anchor, head: this.head };\n  }\n}\n","import { Editor } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\nimport { NodeSelection, Plugin, PluginKey, Selection } from \"prosemirror-state\";\nimport * as pv from \"prosemirror-view\";\nimport { EditorView } from \"prosemirror-view\";\nimport styles from \"../../editor.module.css\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\nimport { SlashMenuPluginKey } from \"../SlashMenu/SlashMenuExtension\";\nimport {\n  BlockSideMenu,\n  BlockSideMenuDynamicParams,\n  BlockSideMenuFactory,\n  BlockSideMenuStaticParams,\n} from \"./BlockSideMenuFactoryTypes\";\nimport { DraggableBlocksOptions } from \"./DraggableBlocksExtension\";\nimport { MultipleNodeSelection } from \"./MultipleNodeSelection\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\nimport { BlockSchema } from \"../Blocks/api/blockTypes\";\n\nconst serializeForClipboard = (pv as any).__serializeForClipboard;\n// code based on https://github.com/ueberdosis/tiptap/issues/323#issuecomment-506637799\n\nlet dragImageElement: Element | undefined;\n\nfunction getDraggableBlockFromCoords(\n  coords: { left: number; top: number },\n  view: EditorView\n) {\n  if (!view.dom.isConnected) {\n    // view is not connected to the DOM, this can cause posAtCoords to fail\n    // (Cannot read properties of null (reading 'nearestDesc'), https://github.com/TypeCellOS/BlockNote/issues/123)\n    return undefined;\n  }\n\n  let pos = view.posAtCoords(coords);\n  if (!pos) {\n    return undefined;\n  }\n  let node = view.domAtPos(pos.pos).node as HTMLElement;\n\n  if (node === view.dom) {\n    // mouse over root\n    return undefined;\n  }\n\n  while (\n    node &&\n    node.parentNode &&\n    node.parentNode !== view.dom &&\n    !node.hasAttribute?.(\"data-id\")\n  ) {\n    node = node.parentNode as HTMLElement;\n  }\n  if (!node) {\n    return undefined;\n  }\n  return { node, id: node.getAttribute(\"data-id\")! };\n}\n\nfunction blockPositionFromCoords(\n  coords: { left: number; top: number },\n  view: EditorView\n) {\n  let block = getDraggableBlockFromCoords(coords, view);\n\n  if (block && block.node.nodeType === 1) {\n    // TODO: this uses undocumented PM APIs? do we need this / let's add docs?\n    const docView = (view as any).docView;\n    let desc = docView.nearestDesc(block.node, true);\n    if (!desc || desc === docView) {\n      return null;\n    }\n    return desc.posBefore;\n  }\n  return null;\n}\n\nfunction blockPositionsFromSelection(selection: Selection, doc: Node) {\n  // Absolute positions just before the first block spanned by the selection, and just after the last block. Having the\n  // selection start and end just before and just after the target blocks ensures no whitespace/line breaks are left\n  // behind after dragging & dropping them.\n  let beforeFirstBlockPos: number;\n  let afterLastBlockPos: number;\n\n  // Even the user starts dragging blocks but drops them in the same place, the selection will still be moved just\n  // before & just after the blocks spanned by the selection, and therefore doesn't need to change if they try to drag\n  // the same blocks again. If this happens, the anchor & head move out of the block content node they were originally\n  // in. If the anchor should update but the head shouldn't and vice versa, it means the user selection is outside a\n  // block content node, which should never happen.\n  const selectionStartInBlockContent =\n    doc.resolve(selection.from).node().type.spec.group === \"blockContent\";\n  const selectionEndInBlockContent =\n    doc.resolve(selection.to).node().type.spec.group === \"blockContent\";\n\n  // Ensures that entire outermost nodes are selected if the selection spans multiple nesting levels.\n  const minDepth = Math.min(selection.$anchor.depth, selection.$head.depth);\n\n  if (selectionStartInBlockContent && selectionEndInBlockContent) {\n    // Absolute positions at the start of the first block in the selection and at the end of the last block. User\n    // selections will always start and end in block content nodes, but we want the start and end positions of their\n    // parent block nodes, which is why minDepth - 1 is used.\n    const startFirstBlockPos = selection.$from.start(minDepth - 1);\n    const endLastBlockPos = selection.$to.end(minDepth - 1);\n\n    // Shifting start and end positions by one moves them just outside the first and last selected blocks.\n    beforeFirstBlockPos = doc.resolve(startFirstBlockPos - 1).pos;\n    afterLastBlockPos = doc.resolve(endLastBlockPos + 1).pos;\n  } else {\n    beforeFirstBlockPos = selection.from;\n    afterLastBlockPos = selection.to;\n  }\n\n  return { from: beforeFirstBlockPos, to: afterLastBlockPos };\n}\n\nfunction setDragImage(view: EditorView, from: number, to = from) {\n  if (from === to) {\n    // Moves to position to be just after the first (and only) selected block.\n    to += view.state.doc.resolve(from + 1).node().nodeSize;\n  }\n\n  // Parent element is cloned to remove all unselected children without affecting the editor content.\n  const parentClone = view.domAtPos(from).node.cloneNode(true) as Element;\n  const parent = view.domAtPos(from).node as Element;\n\n  const getElementIndex = (parentElement: Element, targetElement: Element) =>\n    Array.prototype.indexOf.call(parentElement.children, targetElement);\n\n  const firstSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects from position to be just before the first selected block.\n    view.domAtPos(from + 1).node.parentElement!\n  );\n  const lastSelectedBlockIndex = getElementIndex(\n    parent,\n    // Expects to position to be just after the last selected block.\n    view.domAtPos(to - 1).node.parentElement!\n  );\n\n  for (let i = parent.childElementCount - 1; i >= 0; i--) {\n    if (i > lastSelectedBlockIndex || i < firstSelectedBlockIndex) {\n      parentClone.removeChild(parentClone.children[i]);\n    }\n  }\n\n  // dataTransfer.setDragImage(element) only works if element is attached to the DOM.\n  unsetDragImage();\n  dragImageElement = parentClone;\n\n  // TODO: This is hacky, need a better way of assigning classes to the editor so that they can also be applied to the\n  //  drag preview.\n  const classes = view.dom.className.split(\" \");\n  const inheritedClasses = classes\n    .filter(\n      (className) =>\n        !className.includes(\"bn\") &&\n        !className.includes(\"ProseMirror\") &&\n        !className.includes(\"editor\")\n    )\n    .join(\" \");\n\n  dragImageElement.className =\n    dragImageElement.className +\n    \" \" +\n    styles.dragPreview +\n    \" \" +\n    inheritedClasses;\n\n  document.body.appendChild(dragImageElement);\n}\n\nfunction unsetDragImage() {\n  if (dragImageElement !== undefined) {\n    document.body.removeChild(dragImageElement);\n    dragImageElement = undefined;\n  }\n}\n\nfunction dragStart(e: DragEvent, view: EditorView) {\n  if (!e.dataTransfer) {\n    return;\n  }\n\n  const editorBoundingBox = view.dom.getBoundingClientRect();\n\n  let coords = {\n    left: editorBoundingBox.left + editorBoundingBox.width / 2, // take middle of editor\n    top: e.clientY,\n  };\n\n  let pos = blockPositionFromCoords(coords, view);\n  if (pos != null) {\n    const selection = view.state.selection;\n    const doc = view.state.doc;\n\n    const { from, to } = blockPositionsFromSelection(selection, doc);\n\n    const draggedBlockInSelection = from <= pos && pos < to;\n    const multipleBlocksSelected =\n      selection.$anchor.node() !== selection.$head.node() ||\n      selection instanceof MultipleNodeSelection;\n\n    if (draggedBlockInSelection && multipleBlocksSelected) {\n      view.dispatch(\n        view.state.tr.setSelection(MultipleNodeSelection.create(doc, from, to))\n      );\n      setDragImage(view, from, to);\n    } else {\n      view.dispatch(\n        view.state.tr.setSelection(NodeSelection.create(view.state.doc, pos))\n      );\n      setDragImage(view, pos);\n    }\n\n    let slice = view.state.selection.content();\n    let { dom, text } = serializeForClipboard(view, slice);\n\n    e.dataTransfer.clearData();\n    e.dataTransfer.setData(\"text/html\", dom.innerHTML);\n    e.dataTransfer.setData(\"text/plain\", text);\n    e.dataTransfer.effectAllowed = \"move\";\n    e.dataTransfer.setDragImage(dragImageElement!, 0, 0);\n    view.dragging = { slice, move: true };\n  }\n}\n\nexport type BlockMenuViewProps<BSchema extends BlockSchema> = {\n  tiptapEditor: Editor;\n  editor: BlockNoteEditor<BSchema>;\n  blockMenuFactory: BlockSideMenuFactory<BSchema>;\n  horizontalPosAnchoredAtRoot: boolean;\n};\n\nexport class BlockMenuView<BSchema extends BlockSchema> {\n  editor: BlockNoteEditor<BSchema>;\n  private ttEditor: Editor;\n\n  // When true, the drag handle with be anchored at the same level as root elements\n  // When false, the drag handle with be just to the left of the element\n  horizontalPosAnchoredAtRoot: boolean;\n\n  horizontalPosAnchor: number;\n\n  blockMenu: BlockSideMenu<BSchema>;\n\n  hoveredBlock: HTMLElement | undefined;\n\n  // Used to check if currently dragged content comes from this editor instance.\n  isDragging = false;\n  menuOpen = false;\n  menuFrozen = false;\n\n  private lastPosition: DOMRect | undefined;\n\n  constructor({\n    tiptapEditor,\n    editor,\n    blockMenuFactory,\n    horizontalPosAnchoredAtRoot,\n  }: BlockMenuViewProps<BSchema>) {\n    this.editor = editor;\n    this.ttEditor = tiptapEditor;\n    this.horizontalPosAnchoredAtRoot = horizontalPosAnchoredAtRoot;\n    this.horizontalPosAnchor = (\n      this.ttEditor.view.dom.firstChild! as HTMLElement\n    ).getBoundingClientRect().x;\n\n    this.blockMenu = blockMenuFactory(this.getStaticParams());\n\n    document.body.addEventListener(\"drop\", this.onDrop, true);\n    document.body.addEventListener(\"dragover\", this.onDragOver);\n    this.ttEditor.view.dom.addEventListener(\"dragstart\", this.onDragStart);\n\n    // Shows or updates menu position whenever the cursor moves, if the menu isn't frozen.\n    document.body.addEventListener(\"mousemove\", this.onMouseMove, true);\n\n    // Hides and unfreezes the menu whenever the user selects the editor with the mouse or presses a key.\n    // TODO: Better integration with suggestions menu and only editor scope?\n    document.body.addEventListener(\"mousedown\", this.onMouseDown, true);\n    document.body.addEventListener(\"keydown\", this.onKeyDown, true);\n  }\n\n  /**\n   * Sets isDragging when dragging text.\n   */\n  onDragStart = () => {\n    this.isDragging = true;\n  };\n\n  /**\n   * If the event is outside the editor contents,\n   * we dispatch a fake event, so that we can still drop the content\n   * when dragging / dropping to the side of the editor\n   */\n  onDrop = (event: DragEvent) => {\n    if ((event as any).synthetic || !this.isDragging) {\n      return;\n    }\n    let pos = this.ttEditor.view.posAtCoords({\n      left: event.clientX,\n      top: event.clientY,\n    });\n\n    this.isDragging = false;\n\n    if (!pos || pos.inside === -1) {\n      const evt = new Event(\"drop\", event) as any;\n      const editorBoundingBox = (\n        this.ttEditor.view.dom.firstChild! as HTMLElement\n      ).getBoundingClientRect();\n      evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;\n      evt.clientY = event.clientY;\n      evt.dataTransfer = event.dataTransfer;\n      evt.preventDefault = () => event.preventDefault();\n      evt.synthetic = true; // prevent recursion\n      // console.log(\"dispatch fake drop\");\n      this.ttEditor.view.dom.dispatchEvent(evt);\n    }\n  };\n\n  /**\n   * If the event is outside the editor contents,\n   * we dispatch a fake event, so that we can still drop the content\n   * when dragging / dropping to the side of the editor\n   */\n  onDragOver = (event: DragEvent) => {\n    if ((event as any).synthetic || !this.isDragging) {\n      return;\n    }\n    let pos = this.ttEditor.view.posAtCoords({\n      left: event.clientX,\n      top: event.clientY,\n    });\n\n    if (!pos || pos.inside === -1) {\n      const evt = new Event(\"dragover\", event) as any;\n      const editorBoundingBox = (\n        this.ttEditor.view.dom.firstChild! as HTMLElement\n      ).getBoundingClientRect();\n      evt.clientX = editorBoundingBox.left + editorBoundingBox.width / 2;\n      evt.clientY = event.clientY;\n      evt.dataTransfer = event.dataTransfer;\n      evt.preventDefault = () => event.preventDefault();\n      evt.synthetic = true; // prevent recursion\n      // console.log(\"dispatch fake dragover\");\n      this.ttEditor.view.dom.dispatchEvent(evt);\n    }\n  };\n\n  onKeyDown = (_event: KeyboardEvent) => {\n    if (this.menuOpen) {\n      this.menuOpen = false;\n      this.blockMenu.hide();\n    }\n\n    this.menuFrozen = false;\n  };\n\n  onMouseDown = (event: MouseEvent) => {\n    if (this.blockMenu.element?.contains(event.target as HTMLElement)) {\n      return;\n    }\n\n    if (this.menuOpen) {\n      this.menuOpen = false;\n      this.blockMenu.hide();\n    }\n\n    this.menuFrozen = false;\n  };\n\n  onMouseMove = (event: MouseEvent) => {\n    if (this.menuFrozen) {\n      return;\n    }\n\n    // Editor itself may have padding or other styling which affects\n    // size/position, so we get the boundingRect of the first child (i.e. the\n    // blockGroup that wraps all blocks in the editor) for more accurate side\n    // menu placement.\n    const editorBoundingBox = (\n      this.ttEditor.view.dom.firstChild! as HTMLElement\n    ).getBoundingClientRect();\n    // We want the full area of the editor to check if the cursor is hovering\n    // above it though.\n    const editorOuterBoundingBox =\n      this.ttEditor.view.dom.getBoundingClientRect();\n    const cursorWithinEditor =\n      event.clientX >= editorOuterBoundingBox.left &&\n      event.clientX <= editorOuterBoundingBox.right &&\n      event.clientY >= editorOuterBoundingBox.top &&\n      event.clientY <= editorOuterBoundingBox.bottom;\n\n    // Doesn't update if the mouse hovers an element that's over the editor but\n    // isn't a part of it or the side menu.\n    if (\n      // Cursor is within the editor area\n      cursorWithinEditor &&\n      // An element is hovered\n      event &&\n      event.target &&\n      // Element is outside the editor\n      this.ttEditor.view.dom !== event.target &&\n      !this.ttEditor.view.dom.contains(event.target as HTMLElement) &&\n      // Element is outside the side menu\n      this.blockMenu.element !== event.target &&\n      !this.blockMenu.element?.contains(event.target as HTMLElement)\n    ) {\n      if (this.menuOpen) {\n        this.menuOpen = false;\n        this.blockMenu.hide();\n      }\n\n      return;\n    }\n\n    this.horizontalPosAnchor = editorBoundingBox.x;\n\n    // Gets block at mouse cursor's vertical position.\n    const coords = {\n      left: editorBoundingBox.left + editorBoundingBox.width / 2, // take middle of editor\n      top: event.clientY,\n    };\n    const block = getDraggableBlockFromCoords(coords, this.ttEditor.view);\n\n    // Closes the menu if the mouse cursor is beyond the editor vertically.\n    if (!block || !this.editor.isEditable) {\n      if (this.menuOpen) {\n        this.menuOpen = false;\n        this.blockMenu.hide();\n      }\n\n      return;\n    }\n\n    // Doesn't update if the menu is already open and the mouse cursor is still hovering the same block.\n    if (\n      this.menuOpen &&\n      this.hoveredBlock?.hasAttribute(\"data-id\") &&\n      this.hoveredBlock?.getAttribute(\"data-id\") === block.id\n    ) {\n      return;\n    }\n\n    this.hoveredBlock = block.node;\n\n    // Gets the block's content node, which lets to ignore child blocks when determining the block menu's position.\n    const blockContent = block.node.firstChild as HTMLElement;\n\n    if (!blockContent) {\n      return;\n    }\n\n    // Shows or updates elements.\n    if (this.editor.isEditable) {\n      if (!this.menuOpen) {\n        this.menuOpen = true;\n        this.blockMenu.render(this.getDynamicParams(), true);\n      } else {\n        this.blockMenu.render(this.getDynamicParams(), false);\n      }\n    }\n  };\n\n  destroy() {\n    if (this.menuOpen) {\n      this.menuOpen = false;\n      this.blockMenu.hide();\n    }\n    document.body.removeEventListener(\"mousemove\", this.onMouseMove);\n    document.body.removeEventListener(\"dragover\", this.onDragOver);\n    this.ttEditor.view.dom.removeEventListener(\"dragstart\", this.onDragStart);\n    document.body.removeEventListener(\"drop\", this.onDrop);\n    document.body.removeEventListener(\"mousedown\", this.onMouseDown);\n    document.body.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n\n  addBlock() {\n    this.menuOpen = false;\n    this.menuFrozen = true;\n    this.blockMenu.hide();\n\n    const blockContent = this.hoveredBlock!.firstChild! as HTMLElement;\n    const blockContentBoundingBox = blockContent.getBoundingClientRect();\n\n    const pos = this.ttEditor.view.posAtCoords({\n      left: blockContentBoundingBox.left + blockContentBoundingBox.width / 2,\n      top: blockContentBoundingBox.top + blockContentBoundingBox.height / 2,\n    });\n    if (!pos) {\n      return;\n    }\n\n    const blockInfo = getBlockInfoFromPos(this.ttEditor.state.doc, pos.pos);\n    if (blockInfo === undefined) {\n      return;\n    }\n\n    const { contentNode, endPos } = blockInfo;\n\n    // Creates a new block if current one is not empty for the suggestion menu to open in.\n    if (contentNode.textContent.length !== 0) {\n      const newBlockInsertionPos = endPos + 1;\n      const newBlockContentPos = newBlockInsertionPos + 2;\n\n      this.ttEditor\n        .chain()\n        .BNCreateBlock(newBlockInsertionPos)\n        .BNUpdateBlock(newBlockContentPos, { type: \"paragraph\", props: {} })\n        .setTextSelection(newBlockContentPos)\n        .run();\n    } else {\n      this.ttEditor.commands.setTextSelection(endPos);\n    }\n\n    // Focuses and activates the suggestion menu.\n    this.ttEditor.view.focus();\n    this.ttEditor.view.dispatch(\n      this.ttEditor.view.state.tr.scrollIntoView().setMeta(SlashMenuPluginKey, {\n        // TODO import suggestion plugin key\n        activate: true,\n        type: \"drag\",\n      })\n    );\n  }\n\n  getStaticParams(): BlockSideMenuStaticParams<BSchema> {\n    return {\n      editor: this.editor,\n      addBlock: () => this.addBlock(),\n      blockDragStart: (event: DragEvent) => {\n        // Sets isDragging when dragging blocks.\n        this.isDragging = true;\n        dragStart(event, this.ttEditor.view);\n      },\n      blockDragEnd: () => unsetDragImage(),\n      freezeMenu: () => {\n        this.menuFrozen = true;\n      },\n      unfreezeMenu: () => {\n        this.menuFrozen = false;\n      },\n      getReferenceRect: () => {\n        if (!this.menuOpen) {\n          if (this.lastPosition === undefined) {\n            throw new Error(\n              \"Attempted to access block reference rect before rendering block side menu.\"\n            );\n          }\n\n          return this.lastPosition;\n        }\n\n        const blockContent = this.hoveredBlock!.firstChild! as HTMLElement;\n        const blockContentBoundingBox = blockContent.getBoundingClientRect();\n        if (this.horizontalPosAnchoredAtRoot) {\n          blockContentBoundingBox.x = this.horizontalPosAnchor;\n        }\n        this.lastPosition = blockContentBoundingBox;\n\n        return blockContentBoundingBox;\n      },\n    };\n  }\n\n  getDynamicParams(): BlockSideMenuDynamicParams<BSchema> {\n    return {\n      block: this.editor.getBlock(this.hoveredBlock!.getAttribute(\"data-id\")!)!,\n    };\n  }\n}\n\nexport const createDraggableBlocksPlugin = <BSchema extends BlockSchema>(\n  options: DraggableBlocksOptions<BSchema>\n) => {\n  return new Plugin({\n    key: new PluginKey(\"DraggableBlocksPlugin\"),\n    view: () =>\n      new BlockMenuView({\n        tiptapEditor: options.tiptapEditor,\n        editor: options.editor,\n        blockMenuFactory: options.blockSideMenuFactory,\n        horizontalPosAnchoredAtRoot: true,\n      }),\n  });\n};\n","import { Editor, Extension } from \"@tiptap/core\";\nimport { BlockSideMenuFactory } from \"./BlockSideMenuFactoryTypes\";\nimport { createDraggableBlocksPlugin } from \"./DraggableBlocksPlugin\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\nimport { BlockSchema } from \"../Blocks/api/blockTypes\";\n\nexport type DraggableBlocksOptions<BSchema extends BlockSchema> = {\n  tiptapEditor: Editor;\n  editor: BlockNoteEditor<BSchema>;\n  blockSideMenuFactory: BlockSideMenuFactory<BSchema>;\n};\n\n/**\n * This extension adds a menu to the side of blocks which features various BlockNote functions such as adding and\n * removing blocks. More importantly, it adds a drag handle which allows the user to drag and drop blocks.\n *\n * code based on https://github.com/ueberdosis/tiptap/issues/323#issuecomment-506637799\n */\nexport const createDraggableBlocksExtension = <BSchema extends BlockSchema>() =>\n  Extension.create<DraggableBlocksOptions<BSchema>>({\n    name: \"DraggableBlocksExtension\",\n    priority: 1000, // Need to be high, in order to hide menu when typing slash\n    addProseMirrorPlugins() {\n      if (!this.options.blockSideMenuFactory) {\n        throw new Error(\n          \"UI Element factory not defined for DraggableBlocksExtension\"\n        );\n      }\n      return [\n        createDraggableBlocksPlugin({\n          tiptapEditor: this.editor,\n          editor: this.options.editor,\n          blockSideMenuFactory: this.options.blockSideMenuFactory,\n        }),\n      ];\n    },\n  });\n","import {\n  Editor,\n  isNodeSelection,\n  isTextSelection,\n  posToDOMRect,\n} from \"@tiptap/core\";\nimport { EditorState, Plugin, PluginKey } from \"prosemirror-state\";\nimport { EditorView } from \"prosemirror-view\";\nimport { BlockNoteEditor, BlockSchema } from \"../..\";\nimport {\n  FormattingToolbar,\n  FormattingToolbarFactory,\n  FormattingToolbarStaticParams,\n} from \"./FormattingToolbarFactoryTypes\";\n\n// Same as TipTap bubblemenu plugin, but with these changes:\n// https://github.com/ueberdosis/tiptap/pull/2596/files\nexport interface FormattingToolbarPluginProps<BSchema extends BlockSchema> {\n  pluginKey: PluginKey;\n  tiptapEditor: Editor;\n  editor: BlockNoteEditor<BSchema>;\n  formattingToolbarFactory: FormattingToolbarFactory<BSchema>;\n}\n\nexport type FormattingToolbarViewProps<BSchema extends BlockSchema> =\n  FormattingToolbarPluginProps<BSchema> & {\n    view: EditorView;\n  };\n\nexport class FormattingToolbarView<BSchema extends BlockSchema> {\n  public editor: BlockNoteEditor<BSchema>;\n  private ttEditor: Editor;\n\n  public view: EditorView;\n\n  public formattingToolbar: FormattingToolbar;\n\n  public preventHide = false;\n\n  public preventShow = false;\n\n  public toolbarIsOpen = false;\n\n  public prevWasEditable: boolean | null = null;\n\n  private lastPosition: DOMRect | undefined;\n\n  public shouldShow: (props: {\n    view: EditorView;\n    state: EditorState;\n    from: number;\n    to: number;\n  }) => boolean = ({ view, state, from, to }) => {\n    const { doc, selection } = state;\n    const { empty } = selection;\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock =\n      !doc.textBetween(from, to).length && isTextSelection(state.selection);\n\n    return !(!view.hasFocus() || empty || isEmptyTextBlock);\n  };\n\n  constructor({\n    editor,\n    tiptapEditor,\n    formattingToolbarFactory,\n    view,\n  }: FormattingToolbarViewProps<BSchema>) {\n    this.editor = editor;\n    this.ttEditor = tiptapEditor;\n    this.view = view;\n\n    this.formattingToolbar = formattingToolbarFactory(this.getStaticParams());\n\n    this.view.dom.addEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.view.dom.addEventListener(\"mouseup\", this.viewMouseupHandler);\n    this.view.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n\n    this.ttEditor.on(\"focus\", this.focusHandler);\n    this.ttEditor.on(\"blur\", this.blurHandler);\n  }\n\n  viewMousedownHandler = () => {\n    this.preventShow = true;\n  };\n\n  viewMouseupHandler = () => {\n    this.preventShow = false;\n    setTimeout(() => this.update(this.ttEditor.view));\n  };\n\n  dragstartHandler = () => {\n    this.formattingToolbar.hide();\n    this.toolbarIsOpen = false;\n  };\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.ttEditor.view));\n  };\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false;\n\n      return;\n    }\n\n    // Checks if the focus is moving to an element outside the editor. If it is,\n    // the toolbar is hidden.\n    if (\n      // An element is clicked.\n      event &&\n      event.relatedTarget &&\n      // Element is outside the toolbar.\n      (this.formattingToolbar.element === (event.relatedTarget as Node) ||\n        this.formattingToolbar.element?.contains(event.relatedTarget as Node))\n    ) {\n      return;\n    }\n\n    if (this.toolbarIsOpen) {\n      this.formattingToolbar.hide();\n      this.toolbarIsOpen = false;\n    }\n  };\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state, composing } = view;\n    const { doc, selection } = state;\n    const isSame =\n      oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n\n    if (\n      (this.prevWasEditable === null ||\n        this.prevWasEditable === this.editor.isEditable) &&\n      (composing || isSame)\n    ) {\n      return;\n    }\n\n    this.prevWasEditable = this.editor.isEditable;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    const shouldShow = this.shouldShow?.({\n      view,\n      state,\n      from,\n      to,\n    });\n\n    // Checks if menu should be shown.\n    if (\n      this.editor.isEditable &&\n      !this.toolbarIsOpen &&\n      !this.preventShow &&\n      (shouldShow || this.preventHide)\n    ) {\n      this.formattingToolbar.render({}, true);\n      this.toolbarIsOpen = true;\n\n      return;\n    }\n\n    // Checks if menu should be updated.\n    if (\n      this.toolbarIsOpen &&\n      !this.preventShow &&\n      (shouldShow || this.preventHide)\n    ) {\n      this.formattingToolbar.render({}, false);\n      return;\n    }\n\n    // Checks if menu should be hidden.\n    if (\n      this.toolbarIsOpen &&\n      !this.preventHide &&\n      (!shouldShow || this.preventShow || !this.editor.isEditable)\n    ) {\n      this.formattingToolbar.hide();\n      this.toolbarIsOpen = false;\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.view.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler);\n    this.view.dom.removeEventListener(\"mouseup\", this.viewMouseupHandler);\n    this.view.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n\n    this.ttEditor.off(\"focus\", this.focusHandler);\n    this.ttEditor.off(\"blur\", this.blurHandler);\n  }\n\n  getSelectionBoundingBox() {\n    const { state } = this.ttEditor.view;\n    const { selection } = state;\n\n    // support for CellSelections\n    const { ranges } = selection;\n    const from = Math.min(...ranges.map((range) => range.$from.pos));\n    const to = Math.max(...ranges.map((range) => range.$to.pos));\n\n    if (isNodeSelection(selection)) {\n      const node = this.ttEditor.view.nodeDOM(from) as HTMLElement;\n\n      if (node) {\n        return node.getBoundingClientRect();\n      }\n    }\n\n    return posToDOMRect(this.ttEditor.view, from, to);\n  }\n\n  getStaticParams(): FormattingToolbarStaticParams<BSchema> {\n    return {\n      editor: this.editor,\n      getReferenceRect: () => {\n        if (!this.toolbarIsOpen) {\n          if (this.lastPosition === undefined) {\n            throw new Error(\n              \"Attempted to access selection reference rect before rendering formatting toolbar.\"\n            );\n          }\n\n          return this.lastPosition;\n        }\n\n        const selectionBoundingBox = this.getSelectionBoundingBox();\n        this.lastPosition = selectionBoundingBox;\n\n        return selectionBoundingBox;\n      },\n    };\n  }\n}\n\nexport const createFormattingToolbarPlugin = <BSchema extends BlockSchema>(\n  options: FormattingToolbarPluginProps<BSchema>\n) => {\n  return new Plugin({\n    key: new PluginKey(\"FormattingToolbarPlugin\"),\n    view: (view) => new FormattingToolbarView({ view, ...options }),\n  });\n};\n","import { Extension } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { BlockNoteEditor, BlockSchema } from \"../..\";\nimport { FormattingToolbarFactory } from \"./FormattingToolbarFactoryTypes\";\nimport { createFormattingToolbarPlugin } from \"./FormattingToolbarPlugin\";\n\nexport type FormattingToolbarOptions<BSchema extends BlockSchema> = {\n  formattingToolbarFactory: FormattingToolbarFactory<BSchema>;\n  editor: BlockNoteEditor<BSchema>;\n};\n\n/**\n * The menu that is displayed when selecting a piece of text.\n */\nexport const createFormattingToolbarExtension = <\n  BSchema extends BlockSchema\n>() =>\n  Extension.create<FormattingToolbarOptions<BSchema>>({\n    name: \"FormattingToolbarExtension\",\n\n  addProseMirrorPlugins() {\n    if (!this.options.formattingToolbarFactory || !this.options.editor) {\n      throw new Error(\n        \"required args not defined for FormattingToolbarExtension\"\n      );\n    }\n\n      return [\n        createFormattingToolbarPlugin({\n          tiptapEditor: this.editor,\n          editor: this.options.editor,\n          formattingToolbarFactory: this.options.formattingToolbarFactory,\n          pluginKey: new PluginKey(\"FormattingToolbarPlugin\"),\n        }),\n      ];\n    },\n  });\n","import { Editor, getMarkRange, posToDOMRect, Range } from \"@tiptap/core\";\nimport { Mark } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport {\n  HyperlinkToolbar,\n  HyperlinkToolbarDynamicParams,\n  HyperlinkToolbarFactory,\n  HyperlinkToolbarStaticParams,\n} from \"./HyperlinkToolbarFactoryTypes\";\nconst PLUGIN_KEY = new PluginKey(\"HyperlinkToolbarPlugin\");\n\nexport type HyperlinkToolbarPluginProps = {\n  hyperlinkToolbarFactory: HyperlinkToolbarFactory;\n};\n\nexport type HyperlinkToolbarViewProps = {\n  editor: Editor;\n  hyperlinkToolbarFactory: HyperlinkToolbarFactory;\n};\n\nclass HyperlinkToolbarView {\n  editor: Editor;\n\n  hyperlinkToolbar: HyperlinkToolbar;\n\n  menuUpdateTimer: NodeJS.Timeout | undefined;\n  startMenuUpdateTimer: () => void;\n  stopMenuUpdateTimer: () => void;\n\n  mouseHoveredHyperlinkMark: Mark | undefined;\n  mouseHoveredHyperlinkMarkRange: Range | undefined;\n\n  keyboardHoveredHyperlinkMark: Mark | undefined;\n  keyboardHoveredHyperlinkMarkRange: Range | undefined;\n\n  hyperlinkMark: Mark | undefined;\n  hyperlinkMarkRange: Range | undefined;\n\n  private lastPosition: DOMRect | undefined;\n\n  constructor({ editor, hyperlinkToolbarFactory }: HyperlinkToolbarViewProps) {\n    this.editor = editor;\n\n    this.hyperlinkToolbar = hyperlinkToolbarFactory(this.getStaticParams());\n\n    this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update();\n      }, 250);\n    };\n\n    this.stopMenuUpdateTimer = () => {\n      if (this.menuUpdateTimer) {\n        clearTimeout(this.menuUpdateTimer);\n        this.menuUpdateTimer = undefined;\n      }\n\n      return false;\n    };\n\n    this.editor.view.dom.addEventListener(\"mouseover\", this.mouseOverHandler);\n    document.addEventListener(\"click\", this.clickHandler, true);\n  }\n\n  mouseOverHandler = (event: MouseEvent) => {\n    // Resets the hyperlink mark currently hovered by the mouse cursor.\n    this.mouseHoveredHyperlinkMark = undefined;\n    this.mouseHoveredHyperlinkMarkRange = undefined;\n\n    this.stopMenuUpdateTimer();\n\n    if (\n      event.target instanceof HTMLAnchorElement &&\n      event.target.nodeName === \"A\"\n    ) {\n      // Finds link mark at the hovered element's position to update mouseHoveredHyperlinkMark and\n      // mouseHoveredHyperlinkMarkRange.\n      const hoveredHyperlinkElement = event.target;\n      const posInHoveredHyperlinkMark =\n        this.editor.view.posAtDOM(hoveredHyperlinkElement, 0) + 1;\n      const resolvedPosInHoveredHyperlinkMark = this.editor.state.doc.resolve(\n        posInHoveredHyperlinkMark\n      );\n      const marksAtPos = resolvedPosInHoveredHyperlinkMark.marks();\n\n      for (const mark of marksAtPos) {\n        if (mark.type.name === this.editor.schema.mark(\"link\").type.name) {\n          this.mouseHoveredHyperlinkMark = mark;\n          this.mouseHoveredHyperlinkMarkRange =\n            getMarkRange(\n              resolvedPosInHoveredHyperlinkMark,\n              mark.type,\n              mark.attrs\n            ) || undefined;\n\n          break;\n        }\n      }\n    }\n\n    this.startMenuUpdateTimer();\n\n    return false;\n  };\n\n  clickHandler = (event: MouseEvent) => {\n    if (\n      // Toolbar is open.\n      this.hyperlinkMark &&\n      // An element is clicked.\n      event &&\n      event.target &&\n      // Element is outside the editor.\n      this.editor.view.dom !== (event.target as Node) &&\n      !this.editor.view.dom.contains(event.target as Node) &&\n      // Element is outside the toolbar.\n      this.hyperlinkToolbar.element !== (event.target as Node) &&\n      !this.hyperlinkToolbar.element?.contains(event.target as Node)\n    ) {\n      this.hyperlinkToolbar.hide();\n    }\n  };\n\n  update() {\n    if (!this.editor.view.hasFocus()) {\n      return;\n    }\n\n    // Saves the currently hovered hyperlink mark before it's updated.\n    const prevHyperlinkMark = this.hyperlinkMark;\n\n    // Resets the currently hovered hyperlink mark.\n    this.hyperlinkMark = undefined;\n    this.hyperlinkMarkRange = undefined;\n\n    // Resets the hyperlink mark currently hovered by the keyboard cursor.\n    this.keyboardHoveredHyperlinkMark = undefined;\n    this.keyboardHoveredHyperlinkMarkRange = undefined;\n\n    // Finds link mark at the editor selection's position to update keyboardHoveredHyperlinkMark and\n    // keyboardHoveredHyperlinkMarkRange.\n    if (this.editor.state.selection.empty) {\n      const marksAtPos = this.editor.state.selection.$from.marks();\n\n      for (const mark of marksAtPos) {\n        if (mark.type.name === this.editor.schema.mark(\"link\").type.name) {\n          this.keyboardHoveredHyperlinkMark = mark;\n          this.keyboardHoveredHyperlinkMarkRange =\n            getMarkRange(\n              this.editor.state.selection.$from,\n              mark.type,\n              mark.attrs\n            ) || undefined;\n\n          break;\n        }\n      }\n    }\n\n    if (this.mouseHoveredHyperlinkMark) {\n      this.hyperlinkMark = this.mouseHoveredHyperlinkMark;\n      this.hyperlinkMarkRange = this.mouseHoveredHyperlinkMarkRange;\n    }\n\n    // Keyboard cursor position takes precedence over mouse hovered hyperlink.\n    if (this.keyboardHoveredHyperlinkMark) {\n      this.hyperlinkMark = this.keyboardHoveredHyperlinkMark;\n      this.hyperlinkMarkRange = this.keyboardHoveredHyperlinkMarkRange;\n    }\n\n    if (this.hyperlinkMark && this.editor.isEditable) {\n      this.getDynamicParams();\n\n      // Shows menu.\n      if (!prevHyperlinkMark) {\n        this.hyperlinkToolbar.render(this.getDynamicParams(), true);\n\n        this.hyperlinkToolbar.element?.addEventListener(\n          \"mouseleave\",\n          this.startMenuUpdateTimer\n        );\n        this.hyperlinkToolbar.element?.addEventListener(\n          \"mouseenter\",\n          this.stopMenuUpdateTimer\n        );\n\n        return;\n      }\n\n      // Updates menu.\n      this.hyperlinkToolbar.render(this.getDynamicParams(), false);\n\n      return;\n    }\n\n    // Hides menu.\n    if (prevHyperlinkMark && (!this.hyperlinkMark || !this.editor.isEditable)) {\n      this.hyperlinkToolbar.element?.removeEventListener(\n        \"mouseleave\",\n        this.startMenuUpdateTimer\n      );\n      this.hyperlinkToolbar.element?.removeEventListener(\n        \"mouseenter\",\n        this.stopMenuUpdateTimer\n      );\n\n      this.hyperlinkToolbar.hide();\n\n      return;\n    }\n  }\n\n  destroy() {\n    this.editor.view.dom.removeEventListener(\n      \"mouseover\",\n      this.mouseOverHandler\n    );\n  }\n\n  getStaticParams(): HyperlinkToolbarStaticParams {\n    return {\n      editHyperlink: (url: string, text: string) => {\n        const tr = this.editor.view.state.tr.insertText(\n          text,\n          this.hyperlinkMarkRange!.from,\n          this.hyperlinkMarkRange!.to\n        );\n        tr.addMark(\n          this.hyperlinkMarkRange!.from,\n          this.hyperlinkMarkRange!.from + text.length,\n          this.editor.schema.mark(\"link\", { href: url })\n        );\n        this.editor.view.dispatch(tr);\n        this.editor.view.focus();\n\n        this.hyperlinkToolbar.hide();\n      },\n      deleteHyperlink: () => {\n        this.editor.view.dispatch(\n          this.editor.view.state.tr\n            .removeMark(\n              this.hyperlinkMarkRange!.from,\n              this.hyperlinkMarkRange!.to,\n              this.hyperlinkMark!.type\n            )\n            .setMeta(\"preventAutolink\", true)\n        );\n        this.editor.view.focus();\n\n        this.hyperlinkToolbar.hide();\n      },\n      getReferenceRect: () => {\n        if (!this.hyperlinkMark) {\n          if (this.lastPosition === undefined) {\n            throw new Error(\n              \"Attempted to access hyperlink reference rect before rendering hyperlink toolbar.\"\n            );\n          }\n\n          return this.lastPosition;\n        }\n\n        const hyperlinkBoundingBox = posToDOMRect(\n          this.editor.view,\n          this.hyperlinkMarkRange!.from,\n          this.hyperlinkMarkRange!.to\n        );\n        this.lastPosition = hyperlinkBoundingBox;\n\n        return hyperlinkBoundingBox;\n      },\n    };\n  }\n\n  getDynamicParams(): HyperlinkToolbarDynamicParams {\n    return {\n      url: this.hyperlinkMark!.attrs.href,\n      text: this.editor.view.state.doc.textBetween(\n        this.hyperlinkMarkRange!.from,\n        this.hyperlinkMarkRange!.to\n      ),\n    };\n  }\n}\n\nexport const createHyperlinkToolbarPlugin = (\n  editor: Editor,\n  options: HyperlinkToolbarPluginProps\n) => {\n  return new Plugin({\n    key: PLUGIN_KEY,\n    view: () =>\n      new HyperlinkToolbarView({\n        editor: editor,\n        hyperlinkToolbarFactory: options.hyperlinkToolbarFactory,\n      }),\n  });\n};\n","import { Link } from \"@tiptap/extension-link\";\nimport {\n  createHyperlinkToolbarPlugin,\n  HyperlinkToolbarPluginProps,\n} from \"./HyperlinkToolbarPlugin\";\n\n/**\n * This custom link includes a special menu for editing/deleting/opening the link.\n * The menu will be triggered by hovering over the link with the mouse,\n * or by moving the cursor inside the link text\n */\nconst Hyperlink = Link.extend<HyperlinkToolbarPluginProps>({\n  priority: 500,\n  addProseMirrorPlugins() {\n    if (!this.options.hyperlinkToolbarFactory) {\n      throw new Error(\"UI Element factory not defined for HyperlinkMark\");\n    }\n\n    return [\n      ...(this.parent?.() || []),\n      createHyperlinkToolbarPlugin(this.editor, {\n        hyperlinkToolbarFactory: this.options.hyperlinkToolbarFactory,\n      }),\n    ];\n  },\n});\n\nexport default Hyperlink;\n","import { Editor, Extension } from \"@tiptap/core\";\nimport { Node as ProsemirrorNode } from \"prosemirror-model\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\nimport { SlashMenuPluginKey } from \"../SlashMenu/SlashMenuExtension\";\n\nconst PLUGIN_KEY = new PluginKey(`blocknote-placeholder`);\n\n/**\n * This is a modified version of the tiptap\n * placeholder plugin, that also sets hasAnchorClass\n *\n * It does not set a data-placeholder (text is currently done in css)\n *\n */\nexport interface PlaceholderOptions {\n  emptyEditorClass: string;\n  emptyNodeClass: string;\n  isFilterClass: string;\n  hasAnchorClass: string;\n  placeholder:\n    | ((PlaceholderProps: {\n        editor: Editor;\n        node: ProsemirrorNode;\n        pos: number;\n        hasAnchor: boolean;\n      }) => string)\n    | string;\n  showOnlyWhenEditable: boolean;\n  showOnlyCurrent: boolean;\n  includeChildren: boolean;\n}\n\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: \"placeholder\",\n\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      isFilterClass: \"is-filter\",\n      hasAnchorClass: \"has-anchor\",\n      placeholder: \"Write something …\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false,\n    };\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: PLUGIN_KEY,\n        props: {\n          decorations: (state) => {\n            const { doc, selection } = state;\n            // Get state of slash menu\n            const menuState = SlashMenuPluginKey.getState(state);\n            const active =\n              this.editor.isEditable || !this.options.showOnlyWhenEditable;\n            const { anchor } = selection;\n            const decorations: Decoration[] = [];\n\n            if (!active) {\n              return;\n            }\n\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n              const isEmpty = !node.isLeaf && !node.childCount;\n\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass];\n\n                // TODO: Doesn't work?\n                if (this.editor.isEmpty) {\n                  classes.push(this.options.emptyEditorClass);\n                }\n\n                if (hasAnchor) {\n                  classes.push(this.options.hasAnchorClass);\n                }\n\n                // If slash menu is of drag type and active, show the filter placeholder\n                if (menuState?.triggerCharacter === \"\" && menuState?.active) {\n                  classes.push(this.options.isFilterClass);\n                }\n                // using widget, didn't work (caret position bug)\n                // const decoration = Decoration.widget(\n                //   pos + 1,\n                //   () => {\n                //     const el = document.createElement(\"span\");\n                //     el.innerText = \"hello\";\n                //     return el;\n                //   },\n                //   { side: 0 }\n\n                // Code that sets variables / classes\n                // const ph =\n                //   typeof this.options.placeholder === \"function\"\n                //     ? this.options.placeholder({\n                //         editor: this.editor,\n                //         node,\n                //         pos,\n                //         hasAnchor,\n                //       })\n                //     : this.options.placeholder;\n                // const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                //   class: classes.join(\" \"),\n                //   style: `--placeholder:'${ph.replaceAll(\"'\", \"\\\\'\")}';`,\n                //   \"data-placeholder\": ph,\n                // });\n\n                // Latest version, only set isEmpty and hasAnchor, rest is done via CSS\n\n                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(\" \"),\n                });\n                decorations.push(decoration);\n              }\n\n              return this.options.includeChildren;\n            });\n\n            return DecorationSet.create(doc, decorations);\n          },\n        },\n      }),\n    ];\n  },\n});\n","/**\n * A generic interface used in all suggestion menus (slash menu, mentions, etc)\n */\nexport class SuggestionItem {\n  constructor(public name: string, public match: (query: string) => boolean) {}\n}\n","import { SuggestionItem } from \"../../shared/plugins/suggestion/SuggestionItem\";\nimport { BlockNoteEditor } from \"../../BlockNoteEditor\";\nimport { BlockSchema } from \"../Blocks/api/blockTypes\";\n\n/**\n * A class that defines a slash command (/<command>).\n *\n * (Not to be confused with ProseMirror commands nor TipTap commands.)\n */\nexport class BaseSlashMenuItem<\n  BSchema extends BlockSchema\n> extends SuggestionItem {\n  /**\n   * Constructs a new slash-command.\n   *\n   * @param name The name of the command\n   * @param execute The callback for creating a new node\n   * @param aliases Aliases for this command\n   */\n  constructor(\n    public readonly name: string,\n    public readonly execute: (editor: BlockNoteEditor<BSchema>) => void,\n    public readonly aliases: string[] = []\n  ) {\n    super(name, (query: string): boolean => {\n      return (\n        this.name.toLowerCase().startsWith(query.toLowerCase()) ||\n        this.aliases.filter((alias) =>\n          alias.toLowerCase().startsWith(query.toLowerCase())\n        ).length !== 0\n      );\n    });\n  }\n}\n","import { BlockNoteEditor } from \"../../BlockNoteEditor\";\nimport { PartialBlock } from \"../Blocks/api/blockTypes\";\nimport { DefaultBlockSchema } from \"../Blocks/api/defaultBlocks\";\nimport { BaseSlashMenuItem } from \"./BaseSlashMenuItem\";\n\nfunction insertOrUpdateBlock<BSchema extends DefaultBlockSchema>(\n  editor: BlockNoteEditor<BSchema>,\n  block: PartialBlock<BSchema>\n) {\n  const currentBlock = editor.getTextCursorPosition().block;\n\n  if (\n    (currentBlock.content.length === 1 &&\n      currentBlock.content[0].type === \"text\" &&\n      currentBlock.content[0].text === \"/\") ||\n    currentBlock.content.length === 0\n  ) {\n    editor.updateBlock(currentBlock, block);\n  } else {\n    editor.insertBlocks([block], currentBlock, \"after\");\n    editor.setTextCursorPosition(editor.getTextCursorPosition().nextBlock!);\n  }\n}\n\n/**\n * An array containing commands for creating all default blocks.\n */\nexport const defaultSlashMenuItems = [\n  // Command for creating a level 1 heading\n  new BaseSlashMenuItem<DefaultBlockSchema>(\n    \"Heading\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"heading\",\n        props: { level: \"1\" },\n      }),\n    [\"h\", \"heading1\", \"h1\"]\n  ),\n\n  // Command for creating a level 2 heading\n  new BaseSlashMenuItem<DefaultBlockSchema>(\n    \"Heading 2\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"heading\",\n        props: { level: \"2\" },\n      }),\n    [\"h2\", \"heading2\", \"subheading\"]\n  ),\n\n  // Command for creating a level 3 heading\n  new BaseSlashMenuItem<DefaultBlockSchema>(\n    \"Heading 3\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"heading\",\n        props: { level: \"3\" },\n      }),\n    [\"h3\", \"heading3\", \"subheading\"]\n  ),\n\n  // Command for creating an ordered list\n  new BaseSlashMenuItem<DefaultBlockSchema>(\n    \"Numbered List\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"numberedListItem\",\n      }),\n    [\"li\", \"list\", \"numberedlist\", \"numbered list\"]\n  ),\n\n  // Command for creating a bullet list\n  new BaseSlashMenuItem<DefaultBlockSchema>(\n    \"Bullet List\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"bulletListItem\",\n      }),\n    [\"ul\", \"list\", \"bulletlist\", \"bullet list\"]\n  ),\n\n  // Command for creating a paragraph (pretty useless)\n  new BaseSlashMenuItem<DefaultBlockSchema>(\n    \"Paragraph\",\n    (editor) =>\n      insertOrUpdateBlock(editor, {\n        type: \"paragraph\",\n      }),\n    [\"p\"]\n  ),\n\n  //     replaceRangeWithNode(editor, range, node);\n\n  //     return true;\n  //   },\n  //   [\"ol\", \"orderedlist\"],\n  //   OrderedListIcon,\n  //   \"Used to display an ordered (enumerated) list item\"\n  // ),\n\n  // Command for creating a blockquote\n  // blockquote: new SlashCommand(\n  //   \"Block Quote\",\n  //   CommandGroup.BASIC_BLOCKS,\n  //   (editor, range) => {\n  //     const paragraph = editor.schema.node(\"paragraph\");\n  //     const node = editor.schema.node(\n  //       \"blockquote\",\n  //       { \"block-id\": uniqueId.generate() },\n  //       paragraph\n  //     );\n\n  //     replaceRangeWithNode(editor, range, node);\n\n  //     return true;\n  //   },\n  //   [\"quote\", \"blockquote\"],\n  //   QuoteIcon,\n  //   \"Used to make a quote stand out\",\n  //   \"Ctrl+Shift+B\"\n  // ),\n\n  // Command for creating a horizontal rule\n  // horizontalRule: new SlashCommand(\n  //   \"Horizontal Rule\",\n  //   CommandGroup.BASIC_BLOCKS,\n  //   (editor, range) => {\n  //     const node = editor.schema.node(\"horizontalRule\", {\n  //       \"block-id\": uniqueId.generate(),\n  //     });\n\n  //     // insert horizontal rule, create a new block after the horizontal rule if applicable\n  //     // and put the cursor in the block after the horizontal rule.\n  //     editor\n  //       .chain()\n  //       .focus()\n  //       .replaceRangeAndUpdateSelection(range, node)\n  //       .command(({ tr, dispatch }) => {\n  //         if (dispatch) {\n  //           // the node immediately after the cursor\n  //           const nodeAfter = tr.selection.$to.nodeAfter;\n\n  //           // the position of the cursor\n  //           const cursorPos = tr.selection.$to.pos;\n\n  //           // check if there is no node after the cursor (end of document)\n  //           if (!nodeAfter) {\n  //             // create a new block of the default type (probably paragraph) after the cursor\n  //             const { parent } = tr.selection.$to;\n  //             const node = parent.type.contentMatch.defaultType?.create();\n\n  //             if (node) {\n  //               tr.insert(cursorPos, node);\n  //             }\n  //           }\n\n  //           // try to put the cursor at the start of the node directly after the inserted horizontal rule\n  //           tr.doc.nodesBetween(cursorPos, cursorPos + 1, (node, pos) => {\n  //             if (node.type.name !== \"horizontalRule\") {\n  //               tr.setSelection(TextSelection.create(tr.doc, pos));\n  //             }\n  //           });\n  //         }\n\n  //         return true;\n  //       })\n  //       .scrollIntoView()\n  //       .run();\n  //     return true;\n  //   },\n  //   [\"hr\", \"horizontalrule\"],\n  //   SeparatorIcon,\n  //   \"Used to separate sections with a horizontal line\"\n  // ),\n\n  // Command for creating a table\n  // table: new SlashCommand(\n  //   \"Table\",\n  //   CommandGroup.BASIC_BLOCKS,\n  //   (editor, range) => {\n  //     editor.chain().focus().deleteRange(range).run();\n  //     // TODO: add blockid, pending https://github.com/ueberdosis/tiptap/pull/1469\n  //     editor\n  //       .chain()\n  //       .focus()\n  //       .insertTable({ rows: 1, cols: 2, withHeaderRow: false })\n  //       .scrollIntoView()\n  //       .run();\n  //     return true;\n  //   },\n  //   [\"table\", \"database\"],\n  //   TableIcon,\n  //   \"Used to create a simple table\"\n  // ),\n];\n","import { Extension } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    textAlignment: {\n      setTextAlignment: (\n        textAlignment: \"left\" | \"center\" | \"right\" | \"justify\"\n      ) => ReturnType;\n    };\n  }\n}\n\nexport const TextAlignmentExtension = Extension.create({\n  name: \"textAlignment\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        // Attribute is applied to block content instead of container so that child blocks don't inherit the text\n        // alignment styling.\n        types: [\"paragraph\", \"heading\", \"bulletListItem\", \"numberedListItem\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (element) => element.getAttribute(\"data-text-alignment\"),\n            renderHTML: (attributes) =>\n              attributes.textAlignment !== \"left\" && {\n                \"data-text-alignment\": attributes.textAlignment,\n              },\n          },\n        },\n      },\n    ];\n  },\n\n  addCommands() {\n    return {\n      setTextAlignment:\n        (textAlignment) =>\n        ({ state }) => {\n          const positionsBeforeSelectedContent = [];\n\n          const blockInfo = getBlockInfoFromPos(\n            state.doc,\n            state.selection.from\n          );\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          // Finds all blockContent nodes that the current selection is in.\n          let pos = blockInfo.startPos;\n          while (pos < state.selection.to) {\n            if (\n              state.doc.resolve(pos).node().type.spec.group === \"blockContent\"\n            ) {\n              positionsBeforeSelectedContent.push(pos - 1);\n\n              pos += state.doc.resolve(pos).node().nodeSize - 1;\n            } else {\n              pos += 1;\n            }\n          }\n\n          // Sets text alignment for all blockContent nodes that the current selection is in.\n          for (const pos of positionsBeforeSelectedContent) {\n            state.tr.setNodeAttribute(pos, \"textAlignment\", textAlignment);\n          }\n\n          return true;\n        },\n    };\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { getBlockInfoFromPos } from \"../Blocks/helpers/getBlockInfoFromPos\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    blockTextColor: {\n      setBlockTextColor: (posInBlock: number, color: string) => ReturnType;\n    };\n  }\n}\n\nexport const TextColorExtension = Extension.create({\n  name: \"blockTextColor\",\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          textColor: {\n            default: \"default\",\n            parseHTML: (element) =>\n              element.hasAttribute(\"data-text-color\")\n                ? element.getAttribute(\"data-text-color\")\n                : \"default\",\n            renderHTML: (attributes) =>\n              attributes.textColor !== \"default\" && {\n                \"data-text-color\": attributes.textColor,\n              },\n          },\n        },\n      },\n    ];\n  },\n\n  addCommands() {\n    return {\n      setBlockTextColor:\n        (posInBlock, color) =>\n        ({ state, view }) => {\n          const blockInfo = getBlockInfoFromPos(state.doc, posInBlock);\n          if (blockInfo === undefined) {\n            return false;\n          }\n\n          state.tr.setNodeAttribute(blockInfo.startPos - 1, \"textColor\", color);\n\n          view.focus();\n\n          return true;\n        },\n    };\n  },\n});\n","import { Mark } from \"@tiptap/core\";\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    textColor: {\n      setTextColor: (color: string) => ReturnType;\n    };\n  }\n}\n\nexport const TextColorMark = Mark.create({\n  name: \"textColor\",\n\n  addAttributes() {\n    return {\n      color: {\n        default: undefined,\n        parseHTML: (element) => element.getAttribute(\"data-text-color\"),\n        renderHTML: (attributes) => ({\n          \"data-text-color\": attributes.color,\n        }),\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (element) => {\n          if (typeof element === \"string\") {\n            return false;\n          }\n\n          if (element.hasAttribute(\"data-text-color\")) {\n            return { color: element.getAttribute(\"data-text-color\") };\n          }\n\n          return false;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\"span\", HTMLAttributes, 0];\n  },\n\n  addCommands() {\n    return {\n      setTextColor:\n        (color) =>\n        ({ commands }) => {\n          if (color !== \"default\") {\n            return commands.setMark(this.name, { color: color });\n          }\n\n          return commands.unsetMark(this.name);\n        },\n    };\n  },\n});\n","import { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"prosemirror-state\";\n\n// based on https://github.com/ueberdosis/tiptap/blob/40a9404c94c7fef7900610c195536384781ae101/demos/src/Experiments/TrailingNode/Vue/trailing-node.ts\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  node: string;\n}\n\n/**\n * Add a trailing node to the document so the user can always click at the bottom of the document and start typing\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: \"trailingNode\",\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name);\n    // const disabledNodes = Object.entries(this.editor.schema.nodes)\n    //   .map(([, value]) => value)\n    //   .filter((node) => this.options.notAfter.includes(node.name));\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state;\n          const shouldInsertNodeAtEnd = plugin.getState(state);\n          const endPosition = doc.content.size - 2;\n          const type = schema.nodes[\"blockContainer\"];\n          const contentType = schema.nodes[\"paragraph\"];\n          if (!shouldInsertNodeAtEnd) {\n            return;\n          }\n\n          return tr.insert(\n            endPosition,\n            type.create(undefined, contentType.create())\n          );\n        },\n        state: {\n          init: (_, _state) => {\n            // (maybe fix): use same logic as apply() here\n            // so it works when initializing\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value;\n            }\n\n            let lastNode = tr.doc.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockGroup\") {\n              throw new Error(\"Expected blockGroup\");\n            }\n\n            lastNode = lastNode.lastChild;\n\n            if (!lastNode || lastNode.type.name !== \"blockContainer\") {\n              throw new Error(\"Expected blockContainer\");\n            }\n            return lastNode.nodeSize > 4; // empty <block><content/></block> is length 4\n          },\n        },\n      }),\n    ];\n  },\n});\n","import { Extensions, extensions } from \"@tiptap/core\";\n\nimport { BlockNoteEditor } from \"./BlockNoteEditor\";\n\nimport { Bold } from \"@tiptap/extension-bold\";\nimport { Code } from \"@tiptap/extension-code\";\nimport Collaboration from \"@tiptap/extension-collaboration\";\nimport CollaborationCursor from \"@tiptap/extension-collaboration-cursor\";\nimport { Dropcursor } from \"@tiptap/extension-dropcursor\";\nimport { Gapcursor } from \"@tiptap/extension-gapcursor\";\nimport { HardBreak } from \"@tiptap/extension-hard-break\";\nimport { History } from \"@tiptap/extension-history\";\nimport { Italic } from \"@tiptap/extension-italic\";\nimport { Link } from \"@tiptap/extension-link\";\nimport { Strike } from \"@tiptap/extension-strike\";\nimport { Text } from \"@tiptap/extension-text\";\nimport { Underline } from \"@tiptap/extension-underline\";\nimport * as Y from \"yjs\";\nimport styles from \"./editor.module.css\";\nimport { BackgroundColorExtension } from \"./extensions/BackgroundColor/BackgroundColorExtension\";\nimport { BackgroundColorMark } from \"./extensions/BackgroundColor/BackgroundColorMark\";\nimport { blocks } from \"./extensions/Blocks\";\nimport { BlockSchema } from \"./extensions/Blocks/api/blockTypes\";\nimport { CustomBlockSerializerExtension } from \"./extensions/Blocks/api/serialization\";\nimport blockStyles from \"./extensions/Blocks/nodes/Block.module.css\";\nimport { BlockSideMenuFactory } from \"./extensions/DraggableBlocks/BlockSideMenuFactoryTypes\";\nimport { createDraggableBlocksExtension } from \"./extensions/DraggableBlocks/DraggableBlocksExtension\";\nimport { createFormattingToolbarExtension } from \"./extensions/FormattingToolbar/FormattingToolbarExtension\";\nimport { FormattingToolbarFactory } from \"./extensions/FormattingToolbar/FormattingToolbarFactoryTypes\";\nimport HyperlinkMark from \"./extensions/HyperlinkToolbar/HyperlinkMark\";\nimport { HyperlinkToolbarFactory } from \"./extensions/HyperlinkToolbar/HyperlinkToolbarFactoryTypes\";\nimport { Placeholder } from \"./extensions/Placeholder/PlaceholderExtension\";\nimport {\n  BaseSlashMenuItem,\n  createSlashMenuExtension,\n} from \"./extensions/SlashMenu\";\nimport { TextAlignmentExtension } from \"./extensions/TextAlignment/TextAlignmentExtension\";\nimport { TextColorExtension } from \"./extensions/TextColor/TextColorExtension\";\nimport { TextColorMark } from \"./extensions/TextColor/TextColorMark\";\nimport { TrailingNode } from \"./extensions/TrailingNode/TrailingNodeExtension\";\nimport UniqueID from \"./extensions/UniqueID/UniqueID\";\nimport { SuggestionsMenuFactory } from \"./shared/plugins/suggestion/SuggestionsMenuFactoryTypes\";\n\nexport type UiFactories<BSchema extends BlockSchema> = Partial<{\n  formattingToolbarFactory: FormattingToolbarFactory<BSchema>;\n  hyperlinkToolbarFactory: HyperlinkToolbarFactory;\n  slashMenuFactory: SuggestionsMenuFactory<BaseSlashMenuItem<BSchema>>;\n  blockSideMenuFactory: BlockSideMenuFactory<BSchema>;\n}>;\n\n/**\n * Get all the Tiptap extensions BlockNote is configured with by default\n */\nexport const getBlockNoteExtensions = <BSchema extends BlockSchema>(opts: {\n  editor: BlockNoteEditor<BSchema>;\n  uiFactories: UiFactories<BSchema>;\n  slashCommands: BaseSlashMenuItem<any>[]; // couldn't fix type, see https://github.com/TypeCellOS/BlockNote/pull/191#discussion_r1210708771\n  blockSchema: BSchema;\n  collaboration?: {\n    fragment: Y.XmlFragment;\n    user: {\n      name: string;\n      color: string;\n    };\n    provider: any;\n    renderCursor?: (user: any) => HTMLElement;\n  };\n}) => {\n  const ret: Extensions = [\n    extensions.ClipboardTextSerializer,\n    extensions.Commands,\n    extensions.Editable,\n    extensions.FocusEvents,\n    extensions.Tabindex,\n\n    // DevTools,\n    Gapcursor,\n\n    // DropCursor,\n    Placeholder.configure({\n      emptyNodeClass: blockStyles.isEmpty,\n      hasAnchorClass: blockStyles.hasAnchor,\n      isFilterClass: blockStyles.isFilter,\n      includeChildren: true,\n      showOnlyCurrent: false,\n    }),\n    UniqueID.configure({\n      types: [\"blockContainer\"],\n    }),\n    HardBreak,\n    // Comments,\n\n    // basics:\n    Text,\n\n    // marks:\n    Bold,\n    Code,\n    Italic,\n    Strike,\n    Underline,\n    TextColorMark,\n    TextColorExtension,\n    BackgroundColorMark,\n    BackgroundColorExtension,\n    TextAlignmentExtension,\n\n    // custom blocks:\n    ...blocks,\n    ...Object.values(opts.blockSchema).map((blockSpec) =>\n      blockSpec.node.configure({ editor: opts.editor })\n    ),\n    CustomBlockSerializerExtension,\n\n    Dropcursor.configure({ width: 5, color: \"#ddeeff\" }),\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    TrailingNode,\n  ];\n\n  if (opts.collaboration) {\n    ret.push(\n      Collaboration.configure({\n        fragment: opts.collaboration.fragment,\n      })\n    );\n    const defaultRender = (user: { color: string; name: string }) => {\n      const cursor = document.createElement(\"span\");\n\n      cursor.classList.add(styles[\"collaboration-cursor__caret\"]);\n      cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n\n      const label = document.createElement(\"span\");\n\n      label.classList.add(styles[\"collaboration-cursor__label\"]);\n      label.setAttribute(\"style\", `background-color: ${user.color}`);\n      label.insertBefore(document.createTextNode(user.name), null);\n\n      const nonbreakingSpace1 = document.createTextNode(\"\\u2060\");\n      const nonbreakingSpace2 = document.createTextNode(\"\\u2060\");\n      cursor.insertBefore(nonbreakingSpace1, null);\n      cursor.insertBefore(label, null);\n      cursor.insertBefore(nonbreakingSpace2, null);\n      return cursor;\n    };\n    ret.push(\n      CollaborationCursor.configure({\n        user: opts.collaboration.user,\n        render: opts.collaboration.renderCursor || defaultRender,\n        provider: opts.collaboration.provider,\n      })\n    );\n  } else {\n    // disable history extension when collaboration is enabled as Yjs takes care of undo / redo\n    ret.push(History);\n  }\n\n  if (opts.uiFactories.blockSideMenuFactory) {\n    ret.push(\n      createDraggableBlocksExtension<BSchema>().configure({\n        editor: opts.editor,\n        blockSideMenuFactory: opts.uiFactories.blockSideMenuFactory,\n      })\n    );\n  }\n\n  if (opts.uiFactories.formattingToolbarFactory) {\n    ret.push(\n      createFormattingToolbarExtension<BSchema>().configure({\n        editor: opts.editor,\n        formattingToolbarFactory: opts.uiFactories.formattingToolbarFactory,\n      })\n    );\n  }\n\n  if (opts.uiFactories.hyperlinkToolbarFactory) {\n    ret.push(\n      HyperlinkMark.configure({\n        hyperlinkToolbarFactory: opts.uiFactories.hyperlinkToolbarFactory,\n      })\n    );\n  } else {\n    ret.push(Link);\n  }\n\n  if (opts.uiFactories.slashMenuFactory) {\n    ret.push(\n      createSlashMenuExtension<BSchema>().configure({\n        editor: opts.editor,\n        commands: opts.slashCommands,\n        slashMenuFactory: opts.uiFactories.slashMenuFactory,\n      })\n    );\n  }\n\n  return ret;\n};\n","import { Editor, EditorOptions } from \"@tiptap/core\";\nimport { Node } from \"prosemirror-model\";\n// import \"./blocknote.css\";\nimport { Editor as TiptapEditor } from \"@tiptap/core/dist/packages/core/src/Editor\";\nimport * as Y from \"yjs\";\nimport {\n  insertBlocks,\n  removeBlocks,\n  replaceBlocks,\n  updateBlock,\n} from \"./api/blockManipulation/blockManipulation\";\nimport {\n  blocksToHTML,\n  blocksToMarkdown,\n  HTMLToBlocks,\n  markdownToBlocks,\n} from \"./api/formatConversions/formatConversions\";\nimport { nodeToBlock } from \"./api/nodeConversions/nodeConversions\";\nimport { getNodeById } from \"./api/util/nodeUtil\";\nimport { getBlockNoteExtensions, UiFactories } from \"./BlockNoteExtensions\";\nimport styles from \"./editor.module.css\";\nimport {\n  Block,\n  BlockIdentifier,\n  BlockSchema,\n  PartialBlock,\n} from \"./extensions/Blocks/api/blockTypes\";\nimport { TextCursorPosition } from \"./extensions/Blocks/api/cursorPositionTypes\";\nimport {\n  DefaultBlockSchema,\n  defaultBlockSchema,\n} from \"./extensions/Blocks/api/defaultBlocks\";\nimport {\n  ColorStyle,\n  Styles,\n  ToggledStyle,\n} from \"./extensions/Blocks/api/inlineContentTypes\";\nimport { Selection } from \"./extensions/Blocks/api/selectionTypes\";\nimport { getBlockInfoFromPos } from \"./extensions/Blocks/helpers/getBlockInfoFromPos\";\nimport {\n  BaseSlashMenuItem,\n  defaultSlashMenuItems,\n} from \"./extensions/SlashMenu\";\n\nexport type BlockNoteEditorOptions<BSchema extends BlockSchema> = {\n  // TODO: Figure out if enableBlockNoteExtensions/disableHistoryExtension are needed and document them.\n  enableBlockNoteExtensions: boolean;\n\n  /**\n   * UI element factories for creating a custom UI, including custom positioning\n   * & rendering.\n   */\n  uiFactories: UiFactories<BSchema>;\n  /**\n   * TODO: why is this called slashCommands and not slashMenuItems?\n   *\n   * (couldn't fix any type, see https://github.com/TypeCellOS/BlockNote/pull/191#discussion_r1210708771)\n   *\n   * @default defaultSlashMenuItems from `./extensions/SlashMenu`\n   */\n  slashCommands: BaseSlashMenuItem<any>[];\n\n  /**\n   * The HTML element that should be used as the parent element for the editor.\n   *\n   * @default: undefined, the editor is not attached to the DOM\n   */\n  parentElement: HTMLElement;\n  /**\n   * An object containing attributes that should be added to the editor's HTML element.\n   *\n   * @example { class: \"my-editor-class\" }\n   */\n  editorDOMAttributes: Record<string, string>;\n  /**\n   *  A callback function that runs when the editor is ready to be used.\n   */\n  onEditorReady: (editor: BlockNoteEditor<BSchema>) => void;\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   */\n  onEditorContentChange: (editor: BlockNoteEditor<BSchema>) => void;\n  /**\n   * A callback function that runs whenever the text cursor position changes.\n   */\n  onTextCursorPositionChange: (editor: BlockNoteEditor<BSchema>) => void;\n  /**\n   * Locks the editor from being editable by the user if set to `false`.\n   */\n  editable: boolean;\n  /**\n   * The content that should be in the editor when it's created, represented as an array of partial block objects.\n   */\n  initialContent: PartialBlock<BSchema>[];\n  /**\n   * Use default BlockNote font and reset the styles of <p> <li> <h1> elements etc., that are used in BlockNote.\n   *\n   * @default true\n   */\n  defaultStyles: boolean;\n  /**\n   * Whether to use the light or dark theme.\n   *\n   * @default \"light\"\n   */\n  theme: \"light\" | \"dark\";\n\n  /**\n   * A list of block types that should be available in the editor.\n   */\n  blockSchema: BSchema;\n\n  /**\n   * When enabled, allows for collaboration between multiple users.\n   */\n  collaboration: {\n    /**\n     * The Yjs XML fragment that's used for collaboration.\n     */\n    fragment: Y.XmlFragment;\n    /**\n     * The user info for the current user that's shown to other collaborators.\n     */\n    user: {\n      name: string;\n      color: string;\n    };\n    /**\n     * A Yjs provider (used for awareness / cursor information)\n     */\n    provider: any;\n    /**\n     * Optional function to customize how cursors of users are rendered\n     */\n    renderCursor?: (user: any) => HTMLElement;\n  };\n\n  // tiptap options, undocumented\n  _tiptapOptions: any;\n};\n\nconst blockNoteTipTapOptions = {\n  enableInputRules: true,\n  enablePasteRules: true,\n  enableCoreExtensions: false,\n};\n\nexport class BlockNoteEditor<BSchema extends BlockSchema = DefaultBlockSchema> {\n  public readonly _tiptapEditor: TiptapEditor & { contentComponent: any };\n  public blockCache = new WeakMap<Node, Block<BSchema>>();\n  public readonly schema: BSchema;\n  private ready = false;\n\n  public get domElement() {\n    return this._tiptapEditor.view.dom as HTMLDivElement;\n  }\n\n  public isFocused() {\n    return this._tiptapEditor.view.hasFocus();\n  }\n\n  public focus() {\n    this._tiptapEditor.view.focus();\n  }\n\n  constructor(\n    private readonly options: Partial<BlockNoteEditorOptions<BSchema>> = {}\n  ) {\n    // apply defaults\n    const newOptions: Omit<typeof options, \"defaultStyles\" | \"blockSchema\"> & {\n      defaultStyles: boolean;\n      blockSchema: BSchema;\n    } = {\n      defaultStyles: true,\n      // TODO: There's a lot of annoying typing stuff to deal with here. If\n      //  BSchema is specified, then options.blockSchema should also be required.\n      //  If BSchema is not specified, then options.blockSchema should also not\n      //  be defined. Unfortunately, trying to implement these constraints seems\n      //  to be a huge pain, hence the `as any` casts.\n      blockSchema: options.blockSchema || (defaultBlockSchema as any),\n      ...options,\n    };\n\n    const extensions = getBlockNoteExtensions<BSchema>({\n      editor: this,\n      uiFactories: newOptions.uiFactories || {},\n      slashCommands: newOptions.slashCommands || defaultSlashMenuItems,\n      blockSchema: newOptions.blockSchema,\n      collaboration: newOptions.collaboration,\n    });\n\n    this.schema = newOptions.blockSchema;\n\n    const tiptapOptions: EditorOptions = {\n      // TODO: This approach to setting initial content is \"cleaner\" but requires the PM editor schema, which is only\n      //  created after initializing the TipTap editor. Not sure it's feasible.\n      // content:\n      //   options.initialContent &&\n      //   options.initialContent.map((block) =>\n      //     blockToNode(block, this._tiptapEditor.schema).toJSON()\n      //   ),\n      ...blockNoteTipTapOptions,\n      ...newOptions._tiptapOptions,\n      onCreate: () => {\n        newOptions.onEditorReady?.(this);\n        newOptions.initialContent &&\n          this.replaceBlocks(this.topLevelBlocks, newOptions.initialContent);\n        this.ready = true;\n      },\n      onUpdate: () => {\n        // This seems to be necessary due to a bug in TipTap:\n        // https://github.com/ueberdosis/tiptap/issues/2583\n        if (!this.ready) {\n          return;\n        }\n\n        newOptions.onEditorContentChange?.(this);\n      },\n      onSelectionUpdate: () => {\n        // This seems to be necessary due to a bug in TipTap:\n        // https://github.com/ueberdosis/tiptap/issues/2583\n        if (!this.ready) {\n          return;\n        }\n\n        newOptions.onTextCursorPositionChange?.(this);\n      },\n      editable: options.editable === undefined ? true : options.editable,\n      extensions:\n        newOptions.enableBlockNoteExtensions === false\n          ? newOptions._tiptapOptions?.extensions\n          : [...(newOptions._tiptapOptions?.extensions || []), ...extensions],\n      editorProps: {\n        attributes: {\n          \"data-theme\": options.theme || \"light\",\n          ...(newOptions.editorDOMAttributes || {}),\n          class: [\n            styles.bnEditor,\n            styles.bnRoot,\n            newOptions.defaultStyles ? styles.defaultStyles : \"\",\n            newOptions.editorDOMAttributes?.class || \"\",\n          ].join(\" \"),\n        },\n      },\n    };\n\n    if (newOptions.parentElement) {\n      tiptapOptions.element = newOptions.parentElement;\n    }\n\n    this._tiptapEditor = new Editor(tiptapOptions) as Editor & {\n      contentComponent: any;\n    };\n  }\n\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  public get topLevelBlocks(): Block<BSchema>[] {\n    const blocks: Block<BSchema>[] = [];\n\n    this._tiptapEditor.state.doc.firstChild!.descendants((node) => {\n      blocks.push(nodeToBlock(node, this.schema, this.blockCache));\n\n      return false;\n    });\n\n    return blocks;\n  }\n\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no matching block was found.\n   */\n  public getBlock(\n    blockIdentifier: BlockIdentifier\n  ): Block<BSchema> | undefined {\n    const id =\n      typeof blockIdentifier === \"string\"\n        ? blockIdentifier\n        : blockIdentifier.id;\n    let newBlock: Block<BSchema> | undefined = undefined;\n\n    this._tiptapEditor.state.doc.firstChild!.descendants((node) => {\n      if (typeof newBlock !== \"undefined\") {\n        return false;\n      }\n\n      if (node.type.name !== \"blockContainer\" || node.attrs.id !== id) {\n        return true;\n      }\n\n      newBlock = nodeToBlock(node, this.schema, this.blockCache);\n\n      return false;\n    });\n\n    return newBlock;\n  }\n\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  public forEachBlock(\n    callback: (block: Block<BSchema>) => boolean,\n    reverse: boolean = false\n  ): void {\n    const blocks = this.topLevelBlocks.slice();\n\n    if (reverse) {\n      blocks.reverse();\n    }\n\n    function traverseBlockArray(blockArray: Block<BSchema>[]): boolean {\n      for (const block of blockArray) {\n        if (!callback(block)) {\n          return false;\n        }\n\n        const children = reverse\n          ? block.children.slice().reverse()\n          : block.children;\n\n        if (!traverseBlockArray(children)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    traverseBlockArray(blocks);\n  }\n\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   */\n  public onEditorContentChange(callback: () => void) {\n    this._tiptapEditor.on(\"update\", callback);\n  }\n\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  public getTextCursorPosition(): TextCursorPosition<BSchema> {\n    const { node, depth, startPos, endPos } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    // Index of the current blockContainer node relative to its parent blockGroup.\n    const nodeIndex = this._tiptapEditor.state.doc\n      .resolve(endPos)\n      .index(depth - 1);\n    // Number of the parent blockGroup's child blockContainer nodes.\n    const numNodes = this._tiptapEditor.state.doc\n      .resolve(endPos + 1)\n      .node().childCount;\n\n    // Gets previous blockContainer node at the same nesting level, if the current node isn't the first child.\n    let prevNode: Node | undefined = undefined;\n    if (nodeIndex > 0) {\n      prevNode = this._tiptapEditor.state.doc.resolve(startPos - 2).node();\n    }\n\n    // Gets next blockContainer node at the same nesting level, if the current node isn't the last child.\n    let nextNode: Node | undefined = undefined;\n    if (nodeIndex < numNodes - 1) {\n      nextNode = this._tiptapEditor.state.doc.resolve(endPos + 2).node();\n    }\n\n    return {\n      block: nodeToBlock(node, this.schema, this.blockCache),\n      prevBlock:\n        prevNode === undefined\n          ? undefined\n          : nodeToBlock(prevNode, this.schema, this.blockCache),\n      nextBlock:\n        nextNode === undefined\n          ? undefined\n          : nodeToBlock(nextNode, this.schema, this.blockCache),\n    };\n  }\n\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  public setTextCursorPosition(\n    targetBlock: BlockIdentifier,\n    placement: \"start\" | \"end\" = \"start\"\n  ) {\n    const id = typeof targetBlock === \"string\" ? targetBlock : targetBlock.id;\n\n    const { posBeforeNode } = getNodeById(id, this._tiptapEditor.state.doc);\n    const { startPos, contentNode } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      posBeforeNode + 2\n    )!;\n\n    if (placement === \"start\") {\n      this._tiptapEditor.commands.setTextSelection(startPos + 1);\n    } else {\n      this._tiptapEditor.commands.setTextSelection(\n        startPos + contentNode.nodeSize - 1\n      );\n    }\n  }\n\n  /**\n   * Gets a snapshot of the current selection.\n   */\n  public getSelection(): Selection<BSchema> | undefined {\n    if (\n      this._tiptapEditor.state.selection.from ===\n      this._tiptapEditor.state.selection.to\n    ) {\n      return undefined;\n    }\n\n    const blocks: Block<BSchema>[] = [];\n\n    this._tiptapEditor.state.doc.descendants((node, pos) => {\n      if (node.type.spec.group !== \"blockContent\") {\n        return true;\n      }\n\n      if (\n        pos + node.nodeSize < this._tiptapEditor.state.selection.from ||\n        pos > this._tiptapEditor.state.selection.to\n      ) {\n        return true;\n      }\n\n      blocks.push(\n        nodeToBlock(\n          this._tiptapEditor.state.doc.resolve(pos).node(),\n          this.schema,\n          this.blockCache\n        )\n      );\n\n      return false;\n    });\n\n    return { blocks: blocks };\n  }\n\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  public get isEditable(): boolean {\n    return this._tiptapEditor.isEditable;\n  }\n\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  public set isEditable(editable: boolean) {\n    this._tiptapEditor.setEditable(editable);\n  }\n\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if \"nested\" is used.\n   */\n  public insertBlocks(\n    blocksToInsert: PartialBlock<BSchema>[],\n    referenceBlock: BlockIdentifier,\n    placement: \"before\" | \"after\" | \"nested\" = \"before\"\n  ): void {\n    insertBlocks(blocksToInsert, referenceBlock, placement, this._tiptapEditor);\n  }\n\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  public updateBlock(\n    blockToUpdate: BlockIdentifier,\n    update: PartialBlock<BSchema>\n  ) {\n    updateBlock(blockToUpdate, update, this._tiptapEditor);\n  }\n\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  public removeBlocks(blocksToRemove: BlockIdentifier[]) {\n    removeBlocks(blocksToRemove, this._tiptapEditor);\n  }\n\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  public replaceBlocks(\n    blocksToRemove: BlockIdentifier[],\n    blocksToInsert: PartialBlock<BSchema>[]\n  ) {\n    replaceBlocks(blocksToRemove, blocksToInsert, this._tiptapEditor);\n  }\n\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  public getActiveStyles() {\n    const styles: Styles = {};\n    const marks = this._tiptapEditor.state.selection.$to.marks();\n\n    const toggleStyles = new Set<ToggledStyle>([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\",\n    ]);\n    const colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n    for (const mark of marks) {\n      if (toggleStyles.has(mark.type.name as ToggledStyle)) {\n        styles[mark.type.name as ToggledStyle] = true;\n      } else if (colorStyles.has(mark.type.name as ColorStyle)) {\n        styles[mark.type.name as ColorStyle] = mark.attrs.color;\n      }\n    }\n\n    return styles;\n  }\n\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  public addStyles(styles: Styles) {\n    const toggleStyles = new Set<ToggledStyle>([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\",\n    ]);\n    const colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n    this._tiptapEditor.view.focus();\n\n    for (const [style, value] of Object.entries(styles)) {\n      if (toggleStyles.has(style as ToggledStyle)) {\n        this._tiptapEditor.commands.setMark(style);\n      } else if (colorStyles.has(style as ColorStyle)) {\n        this._tiptapEditor.commands.setMark(style, { color: value });\n      }\n    }\n  }\n\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  public removeStyles(styles: Styles) {\n    this._tiptapEditor.view.focus();\n\n    for (const style of Object.keys(styles)) {\n      this._tiptapEditor.commands.unsetMark(style);\n    }\n  }\n\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  public toggleStyles(styles: Styles) {\n    const toggleStyles = new Set<ToggledStyle>([\n      \"bold\",\n      \"italic\",\n      \"underline\",\n      \"strike\",\n      \"code\",\n    ]);\n    const colorStyles = new Set<ColorStyle>([\"textColor\", \"backgroundColor\"]);\n\n    this._tiptapEditor.view.focus();\n\n    for (const [style, value] of Object.entries(styles)) {\n      if (toggleStyles.has(style as ToggledStyle)) {\n        this._tiptapEditor.commands.toggleMark(style);\n      } else if (colorStyles.has(style as ColorStyle)) {\n        this._tiptapEditor.commands.toggleMark(style, { color: value });\n      }\n    }\n  }\n\n  /**\n   * Gets the currently selected text.\n   */\n  public getSelectedText() {\n    return this._tiptapEditor.state.doc.textBetween(\n      this._tiptapEditor.state.selection.from,\n      this._tiptapEditor.state.selection.to\n    );\n  }\n\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  public getSelectedLinkUrl() {\n    return this._tiptapEditor.getAttributes(\"link\").href as string | undefined;\n  }\n\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  public createLink(url: string, text?: string) {\n    if (url === \"\") {\n      return;\n    }\n\n    let { from, to } = this._tiptapEditor.state.selection;\n\n    if (!text) {\n      text = this._tiptapEditor.state.doc.textBetween(from, to);\n    }\n\n    const mark = this._tiptapEditor.schema.mark(\"link\", { href: url });\n\n    this._tiptapEditor.view.dispatch(\n      this._tiptapEditor.view.state.tr\n        .insertText(text, from, to)\n        .addMark(from, from + text.length, mark)\n    );\n  }\n\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  public canNestBlock() {\n    const { startPos, depth } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    return this._tiptapEditor.state.doc.resolve(startPos).index(depth - 1) > 0;\n  }\n\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  public nestBlock() {\n    this._tiptapEditor.commands.sinkListItem(\"blockContainer\");\n  }\n\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  public canUnnestBlock() {\n    const { depth } = getBlockInfoFromPos(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    )!;\n\n    return depth > 2;\n  }\n\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  public unnestBlock() {\n    this._tiptapEditor.commands.liftListItem(\"blockContainer\");\n  }\n\n  /**\n   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  public async blocksToHTML(blocks: Block<BSchema>[]): Promise<string> {\n    return blocksToHTML(blocks, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  public async HTMLToBlocks(html: string): Promise<Block<BSchema>[]> {\n    return HTMLToBlocks(html, this.schema, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  public async blocksToMarkdown(blocks: Block<BSchema>[]): Promise<string> {\n    return blocksToMarkdown(blocks, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  public async markdownToBlocks(markdown: string): Promise<Block<BSchema>[]> {\n    return markdownToBlocks(markdown, this.schema, this._tiptapEditor.schema);\n  }\n\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  public updateCollaborationUserInfo(user: { name: string; color: string }) {\n    if (!this.options.collaboration) {\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\"\n      );\n    }\n    this._tiptapEditor.commands.updateUser(user);\n  }\n}\n"],"names":["camelToDataKebab","str","propsToAttributes","blockConfig","tiptapAttributes","name","spec","element","attributes","parse","render","HTMLAttributes","blockContent","attribute","value","contentDOM","createBlockSpec","createTipTapBlock","getPos","styles","editor","pos","blockIdentifier","block","rendered","config","Node","HeadingBlockContent","level","InputRule","state","chain","range","node","mergeAttributes","getBlockInfoFromPos","doc","posInBlock","$pos","maxDepth","depth","id","contentNode","contentType","numChildBlocks","startPos","endPos","handleEnter","selectionEmpty","commands","BulletListItemBlockContent","parent","PLUGIN_KEY","PluginKey","NumberedListIndexingPlugin","Plugin","_transactions","_oldState","newState","tr","modified","newIndex","isFirstBlockInDoc","blockInfo","prevBlockInfo","prevBlockContentNode","prevBlockIndex","NumberedListItemBlockContent","ParagraphBlockContent","defaultProps","defaultBlockSchema","removeDuplicates","array","by","seen","item","key","findDuplicates","items","filtered","el","index","UniqueID","Extension","v4","extension","view","types","attributeName","generateID","findChildren","dragSourceElement","transformPasted","transactions","oldState","docChanges","transaction","filterTransactions","_a","_b","transform","combineTransactionSteps","mapping","getChangedRanges","newRange","newNodes","findChildrenInRange","newIds","duplicatedNewIds","deleted","handleDragstart","event","slice","removeId","fragment","list","nodeWithoutId","Fragment","Slice","UnreachableCaseError","val","toggleStyles","colorStyles","styledTextToNodes","styledText","schema","marks","style","text","linkToNodes","link","linkMark","styledTextArrayToNodes","content","nodes","inlineContentToNodes","blockToNode","type","children","child","groupNode","contentNodeToInlineContent","currentContent","commentMark","mark","nodeToBlock","blockSchema","blockCache","cachedBlock","props","attr","blockSpec","propSchema","i","getNodeById","targetNode","posBeforeNode","insertBlocks","blocksToInsert","referenceBlock","placement","nodesToInsert","insertionPos","blockGroupNode","updateBlock","blockToUpdate","update","removeBlocks","blocksToRemove","idsOfBlocksToRemove","removedSize","oldDocSize","newDocSize","notFoundIds","replaceBlocks","removeUnderlines","removeUnderlinesHelper","tree","numChildElements","numElementsAdded","simplifyBlocks","options","listItemBlockTypes","simplifyBlocksHelper","activeList","blockContainer","blockGroup","isListItemBlock","listItemBlockType","numElementsRemoved","fromDom","listItemElement","blocksToHTML","blocks","htmlParentElement","serializer","DOMSerializer","htmlNode","unified","rehypeParse","rehypeStringify","HTMLToBlocks","html","parentNode","DOMParser","blocksToMarkdown","rehypeRemark","remarkGfm","remarkStringify","markdownToBlocks","markdown","htmlString","remarkParse","remarkRehype","BackgroundColorExtension","color","BackgroundColorMark","Mark","nodeAttributes","PreviousBlockTypePlugin","timeout","_editorView","_prevState","prev","currentTransactionOriginalOldBlockAttrs","oldNodes","oldNodesById","oldNode","oldContentNode","newContentNode","newAttrs","oldAttrs","pluginState","decorations","prevAttrs","decorationAttrs","nodeAttr","decoration","Decoration","DecorationSet","BlockAttributes","BlockContainer","attrs","HTMLAttr","dispatch","newBlock","childNodes","posBetweenBlocks","nextNodeIsBlock","prevNodeIsBlock","nextBlockInfo","childBlocksStart","childBlocksEnd","childBlocksRange","prevBlockEndPos","TextSelection","keepType","originalBlockContent","newBlockContent","newBlockInsertionPos","newBlockContentPos","selectionAtBlockStart","isParagraph","blockAtDocStart","blockEmpty","blockIndented","BlockGroup","customBlockSerializer","defaultSerializer","CustomBlockSerializerExtension","findBlock","findParentNode","getDefaultPluginState","SuggestionPluginView","pluginKey","selectItemCallback","suggestionsMenuFactory","__publicField","prevState","next","started","stopped","changed","decorationNode","triggerCharacterBoundingBox","createSuggestionPlugin","defaultTriggerCharacter","deactivate","_c","_d","menuIsActive","triggerCharacter","queryStartPos","keyboardHoveredItemIndex","active","decorationId","blockNode","SlashMenuPluginKey","createSlashMenuExtension","query","cmd","MultipleNodeSelection","Selection","$anchor","$head","_pos","from","to","selection","fromResult","toResult","serializeForClipboard","pv","dragImageElement","getDraggableBlockFromCoords","coords","blockPositionFromCoords","docView","desc","blockPositionsFromSelection","beforeFirstBlockPos","afterLastBlockPos","selectionStartInBlockContent","selectionEndInBlockContent","minDepth","startFirstBlockPos","endLastBlockPos","setDragImage","parentClone","getElementIndex","parentElement","targetElement","firstSelectedBlockIndex","lastSelectedBlockIndex","unsetDragImage","inheritedClasses","className","dragStart","e","editorBoundingBox","draggedBlockInSelection","multipleBlocksSelected","NodeSelection","dom","BlockMenuView","tiptapEditor","blockMenuFactory","horizontalPosAnchoredAtRoot","evt","_event","editorOuterBoundingBox","blockContentBoundingBox","createDraggableBlocksPlugin","createDraggableBlocksExtension","FormattingToolbarView","formattingToolbarFactory","empty","isEmptyTextBlock","isTextSelection","composing","isSame","ranges","shouldShow","isNodeSelection","posToDOMRect","selectionBoundingBox","createFormattingToolbarPlugin","createFormattingToolbarExtension","HyperlinkToolbarView","hyperlinkToolbarFactory","hoveredHyperlinkElement","posInHoveredHyperlinkMark","resolvedPosInHoveredHyperlinkMark","marksAtPos","getMarkRange","prevHyperlinkMark","url","hyperlinkBoundingBox","createHyperlinkToolbarPlugin","Hyperlink","Link","Placeholder","menuState","anchor","hasAnchor","isEmpty","classes","SuggestionItem","match","BaseSlashMenuItem","execute","aliases","alias","insertOrUpdateBlock","currentBlock","defaultSlashMenuItems","TextAlignmentExtension","textAlignment","positionsBeforeSelectedContent","TextColorExtension","TextColorMark","TrailingNode","plugin","_","__","shouldInsertNodeAtEnd","endPosition","_state","lastNode","getBlockNoteExtensions","opts","ret","extensions","Gapcursor","blockStyles","HardBreak","Text","Bold","Code","Italic","Strike","Underline","Dropcursor","Collaboration","defaultRender","user","cursor","label","nonbreakingSpace1","nonbreakingSpace2","CollaborationCursor","History","HyperlinkMark","blockNoteTipTapOptions","BlockNoteEditor","newOptions","tiptapOptions","Editor","callback","reverse","traverseBlockArray","blockArray","nodeIndex","numNodes","prevNode","nextNode","targetBlock","editable"],"mappings":"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"}